<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Matchboxd by eddıe</title>
<style>
:root { --bg:#0e141b; --fg:#c8d0d9; --muted:#8fa0ad; --grid:#1f2a35; --accent:#7dd3fc; --accent2:#a7f3d0; }
* { box-sizing: border-box; }
body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--fg);}
header { padding:16px; border-bottom:1px solid var(--grid); display:flex; align-items:center; justify-content:space-between; gap:12px;}
header h1 { font-size:18px; margin:0;}
.top-actions { display:flex; gap:8px; align-items:center; }
.top-actions input[type=text]{ width:220px; padding:10px 12px; border-radius:10px; border:1px solid #2a3745; background:#0b1016; color:var(--fg); outline:none;}
.top-actions input::placeholder{ color:#6a7b89;}


main { max-width:1620px; margin:24px auto; padding:0 16px 48px;}
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:16px; }
.card { background:#111922; border:1px solid var(--grid); border-radius:12px; padding:16px; box-shadow:0 1px 10px #0006;}
label { display:block; font-size:14px; color:var(--muted); margin-bottom:6px;}
.row{ display:flex; gap:8px; align-items:end;}
.status{ margin-top:8px; color:var(--muted); min-height:1.4em;}
.small{ font-size:12px; color:var(--muted);}
table{ width:100%; border-collapse:collapse; margin-top:12px;}
th,td{ padding:10px 8px; border-bottom:1px solid var(--grid); font-size:14px;}
th{ text-align:left; color:var(--muted); font-weight:600;}
.num{ text-align:right; font-variant-numeric: tabular-nums;}
footer{ color:#6a7b89; text-align:center; font-size:12px; padding:12px 0 32px;}

/* SVGs – APA Style */
.svg { width:100%; height:420px; display:block; background:#ffffff; }
.tick text { fill:#000000; font-size:13px; font-family: Arial, Helvetica, sans-serif; }
.gridline{ stroke:#cccccc; stroke-width:1; }
.diag{ stroke:#666666; stroke-dasharray:4 4; }
.tooltip{ position:absolute; pointer-events:none; transform:translate(-50%, -120%);
  background:#ffffff; border:1px solid #999; border-radius:4px;
  padding:6px 8px; font-size:12px; color:#000000;
  font-family: Arial, Helvetica, sans-serif;
  white-space:nowrap; box-shadow:0 2px 6px rgba(0,0,0,0.15); display:none; }
#heatWrap, #histWrap { position:relative; width:100%; }
.legend {
  display:flex;
  flex-wrap: wrap;
  gap:8px 12px;
  align-items:center;
  font-size:12px;
  color:#000000;
  font-family: Arial, Helvetica, sans-serif;
  margin-top:8px;
}
.swatch { width:12px; height:12px; border-radius:2px; }

/* Prevent mobile zoom on inputs/buttons */
input, button, select, textarea { font-size: 16px !important; }
/* Stack header across all sizes */
header { display:flex; flex-direction: column; align-items:center; gap:12px; text-align:center; }
.top-actions { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
@media (max-width: 560px){
.top-actions{ flex-direction:column; align-items:stretch; }
.top-actions input[type=text] { width:100%; }
}
/* === Loading bar (viewport sweep) === */
.loading-bar{
  position:fixed; top:0; left:0; right:0; height:4px;
  background: transparent; margin:0; border-radius:0; overflow:hidden;
  z-index:9999; pointer-events:none;
}
.loading-bar-indeterminate{
  position:absolute; top:0; bottom:0;
  left:-20%; width:18%; min-width:120px;
  background:linear-gradient(90deg,#007FFF 0%,#ff1fab 60%,#bf430b 100%);
  animation:lb-sweep 1.15s cubic-bezier(.4,0,.2,1) infinite;
}
@keyframes lb-sweep{ 0%{ left:-20%; } 100%{ left:100%; } }
  #panelD .stats-lines div{ margin-top:4px; }
</style>
</head>
<body>
<header>
<h1>Matchboxd by eddıe</h1>
<div class="top-actions">
<input id="userA" type="text" autocapitalize="none" autocomplete="off" placeholder="e.g., eddieslb" />
<input id="userB" type="text" autocapitalize="none" autocomplete="off" placeholder="e.g., steedmanson" />

</div>
</header>

<main>
  <div id="loadingBar" class="loading-bar" hidden aria-live="polite">
  <div class="loading-bar-indeterminate"></div>
</div>
<div class="grid">

<!-- Venn Diagram panel -->
<section class="card" id="panelV">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Venn Diagram</label>
    <div class="small" id="summaryV"></div>
  </div>
  <div id="statusV" class="status"></div>
  <svg id="vennSVG" class="svg" viewBox="0 0 600 400"></svg>
</section>
  
  
<section class="card" id="panelM">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Match Matrix</label>
<div class="small" id="summaryM"></div>
</div>
<div id="statusM" class="status"></div>
<div id="heatWrap">
<svg id="heatSVG" class="svg" viewBox="0 0 600 600"></svg>
<div id="heatTip" class="tooltip"></div>
</div>

</section>

<section class="card" id="panelH">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Agreement Graph</label>
<div class="small" id="summaryH"></div>
</div>
<div id="statusH" class="status"></div>
<div id="histWrap">
<svg id="histSVG" class="svg" viewBox="0 0 700 500"></svg>
<div id="histTip" class="tooltip"></div>
</div>
</section>

<!-- NEW: Descriptive Statistics -->
<section class="card" id="panelD">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Descriptive Statistics</label>
    <div class="small" id="summaryD"></div>
  </div>
  <div id="statusD" class="status"></div>
    <table id="descTbl">
    <thead>
      <tr>
        <th>User</th>
        <th class="num">n</th>
        <th class="num">M</th>
        <th class="num">SD</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="pairStats" class="small stats-lines"></div>
  <div class="small" id="p-legend">* p &lt; .05, ** p &lt; .01, *** p &lt; .001</div>
</section>

<section class="card" id="panelO">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Mutual Movies</label>
<div class="small" id="summaryO"></div>
</div>
<div id="statusO" class="status"></div>
<table id="tblO" hidden>
<thead><tr><th style="width:60%">Title</th><th class="num" style="width:20%">A rating</th><th class="num" style="width:20%">B rating</th></tr></thead>
<tbody></tbody>
</table>
<div class="small" id="stats"></div>
</section>
</div>

<footer>Not affiliated with Letterboxd</footer>
</main>

<script>
function showLoadingBar(){ document.getElementById("loadingBar").hidden = false; }
function hideLoadingBar(){ document.getElementById("loadingBar").hidden = true; }
const $ = (s, r=document) => r.querySelector(s);

// --- Fetch -------------------------------------------------------------------
function normUser(u){ if(!u) return null; u=String(u).trim().replace(/^@/,"").toLowerCase(); return /^[a-z0-9_-]{1,30}$/i.test(u)?u:null; }
async function fetchRatings(user){
  const res = await fetch(`/api/ratings?user=${encodeURIComponent(user)}`, {headers:{Accept:"application/json"}});
  if(!res.ok) throw new Error(`API ${res.status}`); return res.json();
}
function setStatus(el,msg,isErr=false){ el.textContent = msg||""; el.style.color = isErr ? "#ffb3b3" : "#8fa0ad"; }

// --- Shared state + overlap ---------------------------------------------------
let lastA = [], lastB = [];

// Unique identity key for a film: prefer slug, then url, then title+year
const filmKey = it => {
  if (!it) return null;
  if (it.slug) return String(it.slug).toLowerCase();
  if (it.url) {
    const m = it.url.match(/\/film\/([^/]+)\//);
    return (m ? m[1] : it.url).toLowerCase();
  }
  const t = (it.title||"").normalize("NFKD").toLowerCase().replace(/\s+/g," ").trim();
  const y = it.year ? String(it.year) : "";
  return `${t}|${y}`;
};

function computeOverlap(){
  const mapA = new Map(), mapB = new Map();
  const meta = new Map(); // k -> { title, year }

  for (const it of lastA) {
    if (!it?.title) continue;
    const k = filmKey(it);
    mapA.set(k, it.rating);
    const m = meta.get(k) || { title: it.title, year: null };
    if (!m.title && it.title) m.title = it.title;
    if (!m.year && it.year) m.year = it.year;
    meta.set(k, m);
  }

  for (const it of lastB) {
    if (!it?.title) continue;
    const k = filmKey(it);
    mapB.set(k, it.rating);
    const m = meta.get(k) || { title: it.title, year: null };
    if (!m.title && it.title) m.title = it.title;
    if (!m.year && it.year) m.year = it.year;
    meta.set(k, m);
  }

  const rows = [];
  for (const [k, ra] of mapA.entries()) {
    if (mapB.has(k)) {
      const m = meta.get(k) || {};
      const name = m.year ? `${m.title} (${m.year})` : (m.title || "Untitled");
      rows.push({ title: name, a: ra, b: mapB.get(k) });
    }
  }
  rows.sort((x,y)=>x.title.localeCompare(y.title,'en',{sensitivity:'base'}));
  return rows;
}

function calcStats(rows){
  const n = rows.length; if(!n) return {n:0};
  const diffs = rows.map(r=>r.a-r.b);
  const abs = diffs.map(d=>Math.abs(d));
  const mean = diffs.reduce((s,d)=>s+d,0)/n;
  const mae  = abs.reduce((s,d)=>s+d,0)/n;
  const pct0  = (abs.filter(d=>d===0).length/n)*100;
  const pct05 = (abs.filter(d=>d<=0.5).length/n)*100;
  const pct10 = (abs.filter(d=>d<=1.0).length/n)*100;
  const ax = rows.map(r=>r.a), by = rows.map(r=>r.b);
  const meanA = ax.reduce((s,x)=>s+x,0)/n, meanB = by.reduce((s,x)=>s+x,0)/n;
  let num=0, denA=0, denB=0;
  for(let i=0;i<n;i++){ const da=ax[i]-meanA, db=by[i]-meanB; num+=da*db; denA+=da*da; denB+=db*db; }
  const r = (denA>0 && denB>0) ? (num/Math.sqrt(denA*denB)) : 0;
  return {n, meanBias:mean, mae, pct0, pct05, pct10, r};
}

// --- Similarity / Agreement metrics ------------------------------------------
function spearmanRho(rows){
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  const rank = arr => {
    const pairs = arr.map((v,i)=>[v,i]).sort((x,y)=>x[0]-y[0]);
    const r = Array(arr.length);
    for(let i=0;i<pairs.length;){
      let j=i; while(j<pairs.length && pairs[j][0]===pairs[i][0]) j++;
      const avg = (i + j - 1)/2 + 1;
      for(let k=i;k<j;k++) r[pairs[k][1]] = avg;
      i=j;
    }
    return r;
  };
  const ra = rank(a), rb = rank(b);
  return pearson(ra, rb);
}

function pearson(x,y){
  const n=x.length; if(!n) return 0;
  const mx=x.reduce((s,v)=>s+v,0)/n, my=y.reduce((s,v)=>s+v,0)/n;
  let num=0, dx=0, dy=0;
  for(let i=0;i<n;i++){ const a=x[i]-mx, b=y[i]-my; num+=a*b; dx+=a*a; dy+=b*b; }
  return (dx>0 && dy>0) ? num/Math.sqrt(dx*dy) : 0;
}

function kappaQuadratic(rows){
  // ratings are 0.5..5.0 in 0.5 steps → 10 categories
  const step = 0.5, base = 0.5, vmax = 5.0;
  const k = Math.round((vmax - base)/step) + 1; // =10
  const idx = v => Math.max(0, Math.min(k-1, Math.round((v - base)/step)));

  const O = Array.from({length:k},()=>Array(k).fill(0));
  for(const r of rows){ O[idx(r.a)][idx(r.b)]++; }
  const n = rows.length; if(!n) return 0;

  const R = O.map(row=>row.reduce((s,x)=>s+x,0));
  const C = Array.from({length:k},(_,j)=>O.reduce((s,row)=>s+row[j],0));
  // correct denominator uses (k-1)^2 with k=10 → (9)^2 = 81
  const denom = (k-1)*(k-1);
  const W = Array.from({length:k},(_,i)=>Array.from({length:k},(_,j)=>1 - ((i-j)*(i-j))/denom));

  const Po = (1/n) * O.reduce((S,row,i)=> S + row.reduce((s,obs,j)=> s + W[i][j]*obs, 0), 0);
  const Pe = (1/(n*n)) * W.reduce((S,row,i)=> S + row.reduce((s,wij,j)=> s + wij * R[i]*C[j], 0), 0);

  return (1-Pe) ? (Po-Pe)/(1-Pe) : 0;
}
  // === Descriptive Stats helpers ===
function meanSD(arr){
  const n = arr.length;
  if (!n) return {mean: NaN, sd: NaN};
  const m = arr.reduce((s,v)=>s+v,0)/n;
  const v = n>1 ? arr.reduce((s,v)=>{ const d=v-m; return s + d*d; }, 0) / (n-1) : NaN;
  return {mean: m, sd: (v>0?Math.sqrt(v): (n>1?0:NaN))};
}

// Student's t CDF via regularized incomplete beta
function _lnGamma(z){
  const g = 7;
  const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
             771.32342877765313, -176.61502916214059, 12.507343278686905,
             -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
  if(z < 0.5){ return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - _lnGamma(1-z); }
  z -= 1; let x = p[0]; for(let i=1;i<p.length;i++) x += p[i]/(z+i);
  const t = z + g + 0.5;
  return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x) - Math.log(z+1);
}
function _betacf(a,b,x){
  const MAXIT=200, EPS=3e-10, FPMIN=1e-30;
  let qab=a+b, qap=a+1, qam=a-1;
  let c=1, d=1 - qab*x/qap; if(Math.abs(d)<FPMIN) d=FPMIN; d=1/d; let h=d;
  for(let m=1; m<=MAXIT; m++){
    let m2=2*m;
    let aa = m*(b-m)*x/((qam+m2)*(a+m2));
    d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN; h *= d*c;
    aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
    d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN; h *= d*c;
    if(Math.abs(d*c-1) < EPS) break;
  }
  return h;
}
function _betainc(x,a,b){
  if(x<=0) return 0; if(x>=1) return 1;
  const bt = Math.exp(_lnGamma(a+b) - _lnGamma(a) - _lnGamma(b) + a*Math.log(x) + b*Math.log(1-x));
  if(x < (a+1)/(a+b+2)){ return bt * _betacf(a,b,x) / a; }
  return 1 - bt * _betacf(b,a,1-x) / b;
}
function pFromRho(r, n){
  if(!isFinite(r) || n<3) return NaN;
  const df = n - 2;
  const t = Math.abs(r) * Math.sqrt(df / Math.max(1e-12, 1 - r*r));
  const x = df / (df + t*t);
  const ib = _betainc(x, df/2, 0.5);
  const cdf = 1 - 0.5*ib; // t>=0
  const p = 2*(1 - cdf);
  return Math.max(0, Math.min(1, p));
}
function starsForP(p){
  if(!isFinite(p)) return "";
  if(p < 0.001) return "***";
  if(p < 0.01)  return "**";
  if(p < 0.05)  return "*";
  return "";
}
function pTip(p){
  if(!isFinite(p)) return "p = —";
  if(p < 0.001) return "p < .001";
  return "p = " + String(p.toFixed(3)).replace(/^0\./, ".");
}
function pKappaPermutation(rows, perms){
  const n = rows.length; if(n<5) return NaN;
  const obs = kappaQuadratic(rows);
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  let extreme = 0;
  function shuffle(x){ x=x.slice(); for(let i=x.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [x[i],x[j]]=[x[j],x[i]]; } return x; }
  const runs = perms || 10000;  // ↑ was 200–1200
  for(let r=0;r<runs;r++){
    const sb = shuffle(b);
    const k = kappaQuadratic(a.map((v,i)=>({a:v,b:sb[i]})));
    if(Math.abs(k) >= Math.abs(obs)) extreme++;
  }
  return (extreme + 1) / (runs + 1);
}
function pSpearmanPermutation(rows, perms){
  const n = rows.length; if(n<3) return NaN;
  const obs = Math.abs(spearmanRho(rows));
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  let extreme = 0;
  function sh(x){ x=x.slice(); for(let i=x.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [x[i],x[j]]=[x[j],x[i]];} return x; }
  const runs = perms || 10000;
  for(let r=0;r<runs;r++){
    const sb = sh(b);
    const rho = Math.abs(spearmanRho(a.map((v,i)=>({a:v,b:sb[i]}))));
    if(rho >= obs) extreme++;
  }
  return (extreme + 1) / (runs + 1);
}
function renderDescriptiveStats(){
  const status=$("#statusD"), tbl=$("#descTbl"), tbody=$("#descTbl tbody"), summary=$("#summaryD");
  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
    if(!lastA.length || !lastB.length){
    status.textContent = "Fetch both users.";
    tbl.hidden = true; summary.textContent="";
    const ps = $("#pairStats"); if (ps) ps.innerHTML = "";
    return;
  }
  const rows = computeOverlap();
  const nMut = rows.length;
  status.textContent="";
  const aRatingsAll = lastA.map(it=>it.rating).filter(v=>typeof v==="number");
  const bRatingsAll = lastB.map(it=>it.rating).filter(v=>typeof v==="number");
  const {mean: mA, sd: sdA} = meanSD(aRatingsAll);
  const {mean: mB, sd: sdB} = meanSD(bRatingsAll);
  const mae = nMut ? rows.reduce((s,r)=>s + Math.abs(r.a - r.b), 0)/nMut : NaN;
  const rho = nMut ? spearmanRho(rows) : NaN;
  const pRho = isFinite(rho) && nMut>=3 ? pSpearmanPermutation(rows, 10000) : NaN;
  const kq = nMut ? kappaQuadratic(rows) : NaN;
  const pK = isFinite(kq) && nMut>=5 ? pKappaPermutation(rows) : NaN;
  const fmt = (x,d=2)=> isFinite(x) ? x.toFixed(d) : "—";

// table rows: per-user n, M, SD
tbody.innerHTML = [
  `<tr><td>${aName}</td><td class="num">${aRatingsAll.length}</td><td class="num">${fmt(mA)}</td><td class="num">${fmt(sdA)}</td></tr>`,
  `<tr><td>${bName}</td><td class="num">${bRatingsAll.length}</td><td class="num">${fmt(mB)}</td><td class="num">${fmt(sdB)}</td></tr>`
].join("");

// pair lines: MAE, Spearman's ρ, Cohen's κ
const pair = $("#pairStats");
pair.innerHTML = [
  `<div>MAE = ${fmt(mae)}</div>`,
  `<div title="${pTip(pRho)}">Spearman's \u03C1 = ${fmt(rho)}${starsForP(pRho)}</div>`,
  `<div title="${pTip(pK)}">Cohen's \u03BA = ${fmt(kq)}${starsForP(pK)}</div>`
].join("");

// footer line
// summary.textContent = nMut ? `${nMut} mutual films used for MAE/ρ/κ` : "No mutual films";
tbl.hidden = false;
}
// --- Draw helpers -------------------------------------------------------------
function gridAndTicks(
  svg, W, H, m,
  xMin, xMax, yMin, yMax,
  xStep = 1, yStep = 1,
  xLabel = "", yLabel = "",
  centerXTicks = false, centerYTicks = false
){
  const x0=m.left, x1=W-m.right, y0=H-m.bottom, y1=m.top;
  const plotW = x1 - x0, plotH = y0 - y1;

  const xScale = v => x0 + ((v - xMin) / (xMax - xMin)) * plotW;
  const yScale = v => y0 - ((v - yMin) / (yMax - yMin)) * plotH;

  const xBins = Math.round((xMax - xMin)/xStep) + 1;
  const yBins = Math.round((yMax - yMin)/yStep) + 1;
  const bandX = plotW / xBins;
  const bandY = plotH / yBins;
  const xCenter = i => x0 + (i + 0.5) * bandX;
  const yCenter = j => y0 - (j + 0.5) * bandY;

  if (centerXTicks) {
    for (let i = 0; i <= xBins; i++) {
      const X = x0 + i * bandX;
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", X); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", X); ln.setAttribute("y2", y0);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  } else {
    for (let t = xMin; t <= xMax + 1e-9; t += xStep) {
      const X = xScale(t);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", X); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", X); ln.setAttribute("y2", y0);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  }

  if (centerYTicks) {
    for (let j = 0; j <= yBins; j++) {
      const Y = y0 - j * bandY;
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x0); ln.setAttribute("y1", Y);
      ln.setAttribute("x2", x1); ln.setAttribute("y2", Y);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  } else {
    for (let t = yMin; t <= yMax + 1e-9; t += yStep) {
      const Y = yScale(t);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x0); ln.setAttribute("y1", Y);
      ln.setAttribute("x2", x1); ln.setAttribute("y2", Y);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  }

  for (let i = 0; i < xBins; i++) {
    const X = centerXTicks ? xCenter(i) : xScale(xMin + i*xStep);
    const v = +(xMin + i*xStep).toFixed(1);
    const xt = document.createElementNS("http://www.w3.org/2000/svg","text");
    xt.setAttribute("x", X); xt.setAttribute("y", y0 + 22);
    xt.setAttribute("text-anchor","middle"); xt.setAttribute("class","tick");
    xt.textContent = v; svg.appendChild(xt);
  }

  for (let j = 0; j < yBins; j++) {
    const Y = centerYTicks ? yCenter(j) : yScale(yMin + j*yStep);
    const v = +(yMin + j*yStep).toFixed(1);
    const yt = document.createElementNS("http://www.w3.org/2000/svg","text");
    yt.setAttribute("x", x0 - 10); yt.setAttribute("y", Y);
    yt.setAttribute("text-anchor","end");
    yt.setAttribute("alignment-baseline","middle");
    yt.setAttribute("dominant-baseline","central");
    yt.setAttribute("class","tick");
    yt.textContent = v; svg.appendChild(yt);
  }

  const xlabel = document.createElementNS("http://www.w3.org/2000/svg","text");
  xlabel.setAttribute("x",(x0+x1)/2); xlabel.setAttribute("y", y0 + 44);
  xlabel.setAttribute("text-anchor","middle"); xlabel.setAttribute("class","tick");
  xlabel.textContent = xLabel; svg.appendChild(xlabel);

  const ylabel = document.createElementNS("http://www.w3.org/2000/svg","text");
  ylabel.setAttribute("transform",`translate(${m.left - 44} ${(y0+y1)/2}) rotate(-90)`);
  ylabel.setAttribute("text-anchor","middle"); ylabel.setAttribute("class","tick");
  ylabel.textContent = yLabel; svg.appendChild(ylabel);

  return {xScale,yScale,x0,x1,y0,y1};
}

///<script>
  
// --- Venn Diagram -------------------------------------------------------------
function computeTotalsUnique(){
  const A = Array.isArray(lastA) ? lastA : [];
  const B = Array.isArray(lastB) ? lastB : [];
  // count ONLY rated films
  const setA = new Set(), setB = new Set();
  for (const it of A) {
    if (typeof it?.rating === "number") {
      const k = filmKey(it); if (k) setA.add(k);
    }
  }
  for (const it of B) {
    if (typeof it?.rating === "number") {
      const k = filmKey(it); if (k) setB.add(k);
    }
  }
  let common = 0;
  for (const k of setA) if (setB.has(k)) common++;
  return { totA: setA.size, totB: setB.size, common };
}

function _overlapArea(r1, r2, d){
  if (d >= r1 + r2) return 0;
  if (d <= Math.abs(r1 - r2)) return Math.PI * Math.min(r1, r2) ** 2;
  const clamp = x => Math.max(-1, Math.min(1, x));
  const a1 = Math.acos(clamp((d*d + r1*r1 - r2*r2)/(2*d*r1)));
  const a2 = Math.acos(clamp((d*d + r2*r2 - r1*r1)/(2*d*r2)));
  const term = (-d + r1 + r2)*(d + r1 - r2)*(d - r1 + r2)*(d + r1 + r2);
  return r1*r1*a1 + r2*r2*a2 - 0.5*Math.sqrt(Math.max(0, term));
}

function drawVenn(totals, aName="A", bName="B"){
  const svg = document.querySelector("#vennSVG");
  const status = document.querySelector("#statusV");
  const sum = document.querySelector("#summaryV");
  if(!svg) return;
  svg.innerHTML = "";

  const {totA, totB, common} = totals || {};
  if(!isFinite(totA) || !isFinite(totB) || totA<=0 || totB<=0){
    if(status) setStatus(status, "Enter two valid users.");
    if(sum) sum.textContent = "";
    return;
  }
  if(status) setStatus(status, "");

  const W=600, H=400, mL=40, mR=40, mT=20, mB=30;
  svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

  // area-per-film c, scale to fit width AND height
  let c = 12;
  let r1 = Math.sqrt((c*totA)/Math.PI);
  let r2 = Math.sqrt((c*totB)/Math.PI);

  const plotW = W - mL - mR;
  const plotH = H - mT - mB;
  let sW = (r1 + r2) > 0 ? plotW / (r1 + r2) : 1;
  let sH = Math.max(r1, r2) > 0 ? (plotH*0.8) / (2*Math.max(r1, r2)) : 1; // headroom
  const s = Math.min(1, sW, sH);
  if (s < 1){ r1*=s; r2*=s; c*=s*s; }

  // solve distance for target overlap (= common rated)
  const target = c * Math.max(0, Math.min(common, Math.min(totA, totB)));
  const maxContain = Math.PI * Math.min(r1, r2) ** 2;
  let d;

  if (target <= 0) {
    d = r1 + r2;                 // disjoint
  } else if (target >= maxContain) {
    d = Math.abs(r1 - r2);       // containment
  } else {
    let lo = Math.abs(r1 - r2), hi = r1 + r2;
    for (let i=0; i<80; i++){
      const mid = 0.5*(lo+hi);
      const area = _overlapArea(r1, r2, mid);
      if (area >= target) hi = mid; else lo = mid;
    }
    d = Math.min(0.5*(lo+hi), r1 + r2 - 1e-6); // ensure visible overlap
  }

  // center horizontally and vertically
  const span = r1 + d + r2;
  const cx1 = mL + (plotW - span)/2 + r1;
  const cx2 = cx1 + d;
  const cy  = mT + plotH/2;

  const make = n => document.createElementNS("http://www.w3.org/2000/svg", n);

  // circles
  const c1 = make("circle");
  c1.setAttribute("cx", cx1); c1.setAttribute("cy", cy); c1.setAttribute("r", r1);
  c1.setAttribute("fill", "#7dd3fc"); c1.setAttribute("fill-opacity","0.35");
  c1.setAttribute("stroke", "#0a2236"); c1.setAttribute("stroke-width","1");
  svg.appendChild(c1);

  const c2 = make("circle");
  c2.setAttribute("cx", cx2); c2.setAttribute("cy", cy); c2.setAttribute("r", r2);
  c2.setAttribute("fill", "#a7f3d0"); c2.setAttribute("fill-opacity","0.35");
  c2.setAttribute("stroke", "#103321"); c2.setAttribute("stroke-width","1");
  svg.appendChild(c2);

  // labels
  function addText(x,y,text,anchor="middle"){
    const t = make("text");
    t.setAttribute("x", x); t.setAttribute("y", y);
    t.setAttribute("text-anchor", anchor);
    t.setAttribute("font-family", "Arial, Helvetica, sans-serif");
    t.setAttribute("font-size", String(Math.max(12, Math.min(18, Math.round(Math.min(r1,r2)/2)))));
    t.setAttribute("fill", "#000");
    svg.appendChild(t);
    t.textContent = text;
  }
  const fmt = n => isFinite(n) ? n.toLocaleString() : "—";

  // push user labels outside; center common in overlap
  addText(cx1 - r1 - 10, cy, `${aName}: ${fmt(totA)}`, "end");
  addText(cx2 + r2 + 10, cy, `${bName}: ${fmt(totB)}`, "start");
  addText((cx1+cx2)/2, cy + Math.min(r1,r2)*0.2, `common: ${fmt(common)}`);

  if (sum) sum.textContent = `${aName} ${fmt(totA)} · ${bName} ${fmt(totB)} · common ${fmt(common)}`;
}
// --- end Venn Diagram ---------------------------------------------------------

// --- Heatmap ------------------------------------------------------------------
function drawHeatmap(rows, aName="A", bName="B"){
  const svg=$("#heatSVG"), tip=$("#heatTip"), status=$("#statusM"), sum=$("#summaryM");
  const W=600, H=600, m={left:68, right:28, top:36, bottom:72};
  svg.innerHTML="";
  if(!rows || !rows.length){ setStatus(status,"No overlap yet."); sum.textContent=""; return; }
  setStatus(status,"");

  const {xScale,yScale,x0,x1,y0,y1} =
  gridAndTicks(svg, W, H, m, 0.5, 5.0, 0.5, 5.0, 0.5, 0.5, `${aName} rating`, `${bName} rating`, true, true);

  const step=0.5, base=0.5, vals=Array.from({length:10},(_,i)=>+(base + i*step).toFixed(1));

  const counts = new Map(); let maxCount=0;
  rows.forEach(r=>{
    const ax = +(Math.round(r.a/step)*step).toFixed(1);
    const by = +(Math.round(r.b/step)*step).toFixed(1);
    const k = `${ax}|${by}`;
    const v = (counts.get(k)||0) + 1;
    counts.set(k, v);
    if(v>maxCount) maxCount=v;
  });

  const bins = vals.length;
  const bandX  = (x1 - x0) / bins;
  const bandY  = (y0 - y1) / bins;
  const cellW  = bandX * 0.92;
  const cellH  = bandY * 0.92;
  const padX   = (bandX - cellW) / 2;
  const padY   = (bandY - cellH) / 2;

  function color(t){
    const v = Math.sqrt(Math.max(0,Math.min(1,t)));
    const shade = 255 - Math.round(155*v);
    return `rgb(${shade},${shade},255)`;
  }

  vals.forEach((ax, i)=>{
    vals.forEach((by, j)=>{
      const k = `${ax}|${by}`;
      const v = counts.get(k) || 0;

      const x = x0 + i * bandX + padX;
      const y = y1 + (bins - 1 - j) * bandY + padY;
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width",  cellW);
      rect.setAttribute("height", cellH);
      rect.setAttribute("fill", v ? color(v/maxCount) : "rgb(240,240,255)");
      rect.setAttribute("stroke", "#e6e6f8");
      rect.addEventListener("mouseenter",()=>{
        if(!v) return;
        tip.style.display="block";
        tip.textContent = `${aName} ${ax}★, ${bName} ${by}★ — ${v} (${Math.round(100*v/rows.length)}%)`;
      });
      rect.addEventListener("mousemove",e=>{
        const rectB = $("#heatWrap").getBoundingClientRect();
        tip.style.left=(e.clientX-rectB.left)+"px";
        tip.style.top =(e.clientY-rectB.top)+"px";
      });
      rect.addEventListener("mouseleave",()=>{ tip.style.display="none"; });
      svg.appendChild(rect);

      if(v>0 && cellW>=40 && cellH>=24){
        const t = document.createElementNS("http://www.w3.org/2000/svg","text");
        t.setAttribute("x", x + cellW/2);
        t.setAttribute("y", y + cellH/2 + 4);
        t.setAttribute("text-anchor","middle");
        t.setAttribute("class","tick");
        t.textContent = v;
        svg.appendChild(t);
      }
    });
  });
  const diag=document.createElementNS("http://www.w3.org/2000/svg","line");
  diag.setAttribute("x1", x0);
  diag.setAttribute("y1", y0);
  diag.setAttribute("x2", x1);
  diag.setAttribute("y2", y1);
  diag.setAttribute("class","diag"); svg.appendChild(diag);

}

// --- Histogram of absolute differences ---------------------------------------
function drawHistogram(rows, aName="A", bName="B"){
  const svg=$("#histSVG"), tip=$("#histTip"), status=$("#statusH"), sum=$("#summaryH");
  const W=700, H=520, m={left:68, right:28, top:36, bottom:72};
  svg.innerHTML="";
  if(!rows || !rows.length){ setStatus(status,"No overlap yet."); sum.textContent=""; return; }
  setStatus(status,"");

  const step = 0.5;
  const bins = Array.from({length:10}, (_,i) => +(i*step).toFixed(1)); // 0..4.5
  const counts = new Array(bins.length).fill(0);
  rows.forEach(r => { const d = Math.abs(r.a - r.b); const idx = Math.round(d/step); if(idx >= 0 && idx < counts.length) counts[idx]++; });
  const n = rows.length;
  const props = counts.map(c => (100*c/n));
  const maxPct  = Math.max(...props, 0);
  const yMaxDyn = Math.min(100, Math.max(10, Math.ceil(maxPct/10)*10));
    sum.textContent = `Exact ${props[0].toFixed(0)}% · ≤0.5★ ${(props[0]+props[1]).toFixed(0)}% · ≤1★ ${(props[0]+props[1]+props[2]).toFixed(0)}%`;

  const {xScale,yScale,x0,x1,y0,y1} =
  gridAndTicks(svg, W, H, m,
    0, 4.5,
    0, yMaxDyn,
    0.5, 10,
    `|${aName}−${bName}| (★)`, "Share of titles (%)",
    true, false);

  const band = (x1 - x0) / bins.length;
  const barW = band * 0.72;

  bins.forEach((b, i) => {
    const v = props[i];
    const x = x0 + i * band + (band - barW) / 2;
    const y = yScale(v);
    const h = yScale(0) - y;

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", x); rect.setAttribute("y", y);
    rect.setAttribute("width", barW); rect.setAttribute("height", Math.max(0, h));
    rect.setAttribute("fill", "#666666");
    rect.setAttribute("stroke", "#e0e0e0");
    rect.addEventListener("mouseenter", ()=>{ tip.style.display="block"; tip.textContent = `|${aName}−${bName}| = ${b}★ → ${v.toFixed(1)}% (${counts[i]} films)`; });
    rect.addEventListener("mousemove", e=>{ const rectW=$("#histWrap").getBoundingClientRect(); tip.style.left=(e.clientX-rectW.left)+"px"; tip.style.top=(e.clientY-rectW.top)+"px";});
    rect.addEventListener("mouseleave", ()=>{ tip.style.display="none"; });
    svg.appendChild(rect);

    if(v >= 0.5){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", x + barW/2); t.setAttribute("y", y - 6);
      t.setAttribute("text-anchor", "middle"); t.setAttribute("class","tick");
      t.textContent = v.toFixed(0) + "%";
      svg.appendChild(t);
    }
  });
}

// --- Orchestration ------------------------------------------------------------
function updateAllViews(){
  const rows = computeOverlap();

  const status=$("#statusO"), tbl=$("#tblO"), tbody=$("#tblO tbody"), summary=$("#summaryO"), statsEl=$("#stats");
  if(!rows.length){
    setStatus(status,"Fetch both to see overlaps.");
    tbl.hidden=true; summary.textContent=""; statsEl.textContent="";
  } else {
    setStatus(status,""); summary.textContent=`${rows.length} films in common`;
    tbody.innerHTML = rows.map(r=>`<tr><td>${r.title}</td><td class="num">${r.a.toFixed(1)}</td><td class="num">${r.b.toFixed(1)}</td></tr>`).join("");
    tbl.hidden=false;
    const s = calcStats(rows);
    const rho = spearmanRho(rows);
    const kq  = kappaQuadratic(rows);
      statsEl.textContent =
      `Exact ${s.pct0.toFixed(0)}% · ≤0.5★ ${s.pct05.toFixed(0)}% · ≤1★ ${s.pct10.toFixed(0)}% ` +
      `· Bias (A−B): ${s.meanBias.toFixed(2)}★ · MAE: ${s.mae.toFixed(2)}★ · Spearman's ρ: ${rho.toFixed(2)} · Cohen's κ: ${kq.toFixed(2)}`;
  }

  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
  drawVenn(computeTotalsUnique(), aName, bName);
  drawHeatmap(rows, aName, bName);
  drawHistogram(rows, aName, bName);
  renderDescriptiveStats(); 
}

async function runBoth(){
  const status = $("#statusO");
  const uA = normUser($("#userA").value);
  const uB = normUser($("#userB").value);
  if(!uA || !uB){ setStatus(status,"Enter two valid usernames.", true); return; }
  
  showLoadingBar();
  try{
    const [a, b] = await Promise.all([fetchRatings(uA), fetchRatings(uB)]);
    lastA = a.items || [];
    lastB = b.items || [];
    setStatus(status,"");
    updateAllViews();
    hideLoadingBar();
  }catch(e){
    setStatus(status, e.message || String(e), true);
    hideLoadingBar();
    lastA = []; lastB = [];
    updateAllViews();
  }
}

$("#userA").addEventListener("keydown", e => { if(e.key==="Enter"){ e.preventDefault(); runBoth(); }});
$("#userB").addEventListener("keydown", e => { if(e.key==="Enter"){ e.preventDefault(); runBoth(); }});
</script>
</body>
</html>
