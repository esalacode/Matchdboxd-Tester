<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Matchboxd by eddıe</title>
<style>
:root { --bg:#0e141b; --fg:#c8d0d9; --muted:#8fa0ad; --grid:#1f2a35; --accent:#7dd3fc; --accent2:#a7f3d0; }
* { box-sizing: border-box; }
body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--fg);}
header { padding:16px; border-bottom:1px solid var(--grid); display:flex; align-items:center; justify-content:space-between; gap:12px;}
header h1 { font-size:18px; margin:0;}
.top-actions { display:flex; gap:8px; align-items:center; }
.top-actions input[type=text]{ width:220px; padding:10px 12px; border-radius:10px; border:1px solid #2a3745; background:#0b1016; color:var(--fg); outline:none;}
.top-actions input::placeholder{ color:#6a7b89;}


main { max-width:1620px; margin:24px auto; padding:0 16px 48px;}
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:16px; }
.card { background:#111922; border:1px solid var(--grid); border-radius:12px; padding:16px; box-shadow:0 1px 10px #0006;}
label { display:block; font-size:14px; color:var(--muted); margin-bottom:6px;}
.row{ display:flex; gap:8px; align-items:end;}
.status{ margin-top:8px; color:var(--muted); min-height:1.4em;}
.small{ font-size:12px; color:var(--muted);}
table{ width:100%; border-collapse:collapse; margin-top:12px;}
th,td{ padding:10px 8px; border-bottom:1px solid var(--grid); font-size:14px;}
th{ text-align:left; color:var(--muted); font-weight:600;}
.num{ text-align:right; font-variant-numeric: tabular-nums;}
footer{ color:#6a7b89; text-align:center; font-size:12px; padding:12px 0 32px;}

/* SVGs – APA Style */
.svg { width:100%; height:420px; display:block; background:#ffffff; }
.tick text { fill:#000000; font-size:13px; font-family: Arial, Helvetica, sans-serif; }
.gridline{ stroke:#cccccc; stroke-width:1; }
.diag{ stroke:#666666; stroke-dasharray:4 4; }
.tooltip{ position:absolute; pointer-events:none; transform:translate(-50%, -120%);
  background:#ffffff; border:1px solid #999; border-radius:4px;
  padding:6px 8px; font-size:12px; color:#000000;
  font-family: Arial, Helvetica, sans-serif;
  white-space:nowrap; box-shadow:0 2px 6px rgba(0,0,0,0.15); display:none; }
#heatWrap, #histWrap { position:relative; width:100%; }
.legend {
  display:flex;
  flex-wrap: wrap;
  gap:8px 12px;
  align-items:center;
  font-size:12px;
  color:#000000;
  font-family: Arial, Helvetica, sans-serif;
  margin-top:8px;
}
.swatch { width:12px; height:12px; border-radius:2px; }

/* Prevent mobile zoom on inputs/buttons */
input, button, select, textarea { font-size: 16px !important; }
/* Stack header across all sizes */
header { display:flex; flex-direction: column; align-items:center; gap:12px; text-align:center; }
.top-actions { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
@media (max-width: 560px){
.top-actions{ flex-direction:column; align-items:stretch; }
.top-actions input[type=text] { width:100%; }
}
/* === Loading bar (viewport sweep) === */
.loading-bar{
  position:fixed; top:0; left:0; right:0; height:4px;
  background: transparent; margin:0; border-radius:0; overflow:hidden;
  z-index:9999; pointer-events:none;
}
.loading-bar-indeterminate{
  position:absolute; top:0; bottom:0;
  left:-20%; width:18%; min-width:120px;
  background:linear-gradient(90deg,#007FFF 0%,#ff1fab 60%,#bf430b 100%);
  animation:lb-sweep 1.15s cubic-bezier(.4,0,.2,1) infinite;
}
@keyframes lb-sweep{ 0%{ left:-20%; } 100%{ left:100%; } }
  #panelD .stats-lines div{ margin-top:4px; }
</style>
</head>
<body>
<header>
<h1>Matchboxd by eddıe</h1>
<div class="top-actions">
<input id="userA" type="text" autocapitalize="none" autocomplete="off" placeholder="e.g., eddieslb" />
<input id="userB" type="text" autocapitalize="none" autocomplete="off" placeholder="e.g., steedmanson" />

</div>
</header>

<main>
  <div id="loadingBar" class="loading-bar" hidden aria-live="polite">
  <div class="loading-bar-indeterminate"></div>
</div>
<div class="grid">

<!-- Venn Diagram panel -->
<section class="card" id="panelV">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Venn Diagram</label>
    <div class="small" id="summaryV"></div>
  </div>
  <div id="statusV" class="status"></div>
  <div id="vennWrap" style="position:relative;width:100%;">
  <svg id="vennSVG" class="svg" viewBox="0 0 600 400"></svg>
  <div id="vennTip" class="tooltip"></div>
</div>
</section>
  
  
<section class="card" id="panelM">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Match Matrix</label>
<div class="small" id="summaryM"></div>
</div>
<div id="statusM" class="status"></div>
<div id="heatWrap">
<svg id="heatSVG" class="svg" viewBox="0 0 600 600"></svg>
<div id="heatTip" class="tooltip"></div>
</div>

</section>

<section class="card" id="panelH">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Agreement Graph</label>
<div class="small" id="summaryH"></div>
</div>
<div id="statusH" class="status"></div>
<div id="histWrap">
<svg id="histSVG" class="svg" viewBox="0 0 700 500"></svg>
<div id="histTip" class="tooltip"></div>
</div>
</section>

<!-- NEW: Descriptive Statistics -->
<section class="card" id="panelD">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Descriptive Statistics</label>
    <div class="small" id="summaryD"></div>
  </div>
  <div id="statusD" class="status"></div>
    <table id="descTbl">
    <thead>
      <tr>
        <th>User</th>
        <th class="num">n</th>
        <th class="num">M</th>
        <th class="num">SD</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="pairStats" class="small stats-lines"></div>
  <div class="small" id="p-legend">* p &lt; .05, ** p &lt; .01, *** p &lt; .001</div>
</section>

<section class="card" id="panelO">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Mutual Movies</label>
<div class="small" id="summaryO"></div>
</div>
<div id="statusO" class="status"></div>
<table id="tblO" hidden>
<thead><tr><th style="width:60%">Title</th><th class="num" style="width:20%">A rating</th><th class="num" style="width:20%">B rating</th></tr></thead>
<tbody></tbody>
</table>
<div class="small" id="stats"></div>
</section>
</div>

<footer>Not affiliated with Letterboxd</footer>
</main>

<script>
function showLoadingBar(){ document.getElementById("loadingBar").hidden = false; }
function hideLoadingBar(){ document.getElementById("loadingBar").hidden = true; }
const $ = (s, r=document) => r.querySelector(s);

// --- Fetch -------------------------------------------------------------------
function normUser(u){ if(!u) return null; u=String(u).trim().replace(/^@/,"").toLowerCase(); return /^[a-z0-9_-]{1,30}$/i.test(u)?u:null; }
async function fetchRatings(user){
  const res = await fetch(`/api/ratings?user=${encodeURIComponent(user)}`, {headers:{Accept:"application/json"}});
  if(!res.ok) throw new Error(`API ${res.status}`); return res.json();
}
function setStatus(el,msg,isErr=false){ el.textContent = msg||""; el.style.color = isErr ? "#ffb3b3" : "#8fa0ad"; }

// --- Shared state + overlap ---------------------------------------------------
let lastA = [], lastB = [];

// Unique identity key for a film: prefer slug, then url, then title+year
const filmKey = it => {
  if (!it) return null;
  if (it.slug) return String(it.slug).toLowerCase();
  if (it.url) {
    const m = it.url.match(/\/film\/([^/]+)\//);
    return (m ? m[1] : it.url).toLowerCase();
  }
  const t = (it.title||"").normalize("NFKD").toLowerCase().replace(/\s+/g," ").trim();
  const y = it.year ? String(it.year) : "";
  return `${t}|${y}`;
};

function computeOverlap(){
  const mapA = new Map(), mapB = new Map();
  const meta = new Map(); // k -> { title, year }

  for (const it of lastA) {
    if (!it?.title) continue;
    const k = filmKey(it);
    mapA.set(k, it.rating);
    const m = meta.get(k) || { title: it.title, year: null };
    if (!m.title && it.title) m.title = it.title;
    if (!m.year && it.year) m.year = it.year;
    meta.set(k, m);
  }

  for (const it of lastB) {
    if (!it?.title) continue;
    const k = filmKey(it);
    mapB.set(k, it.rating);
    const m = meta.get(k) || { title: it.title, year: null };
    if (!m.title && it.title) m.title = it.title;
    if (!m.year && it.year) m.year = it.year;
    meta.set(k, m);
  }

  const rows = [];
  for (const [k, ra] of mapA.entries()) {
    if (mapB.has(k)) {
      const m = meta.get(k) || {};
      const name = m.year ? `${m.title} (${m.year})` : (m.title || "Untitled");
      rows.push({ title: name, a: ra, b: mapB.get(k) });
    }
  }
  rows.sort((x,y)=>x.title.localeCompare(y.title,'en',{sensitivity:'base'}));
  return rows;
}

function calcStats(rows){
  const n = rows.length; if(!n) return {n:0};
  const diffs = rows.map(r=>r.a-r.b);
  const abs = diffs.map(d=>Math.abs(d));
  const mean = diffs.reduce((s,d)=>s+d,0)/n;
  const mae  = abs.reduce((s,d)=>s+d,0)/n;
  const pct0  = (abs.filter(d=>d===0).length/n)*100;
  const pct05 = (abs.filter(d=>d<=0.5).length/n)*100;
  const pct10 = (abs.filter(d=>d<=1.0).length/n)*100;
  const ax = rows.map(r=>r.a), by = rows.map(r=>r.b);
  const meanA = ax.reduce((s,x)=>s+x,0)/n, meanB = by.reduce((s,x)=>s+x,0)/n;
  let num=0, denA=0, denB=0;
  for(let i=0;i<n;i++){ const da=ax[i]-meanA, db=by[i]-meanB; num+=da*db; denA+=da*da; denB+=db*db; }
  const r = (denA>0 && denB>0) ? (num/Math.sqrt(denA*denB)) : 0;
  return {n, meanBias:mean, mae, pct0, pct05, pct10, r};
}

// --- Similarity / Agreement metrics ------------------------------------------
function spearmanRho(rows){
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  const rank = arr => {
    const pairs = arr.map((v,i)=>[v,i]).sort((x,y)=>x[0]-y[0]);
    const r = Array(arr.length);
    for(let i=0;i<pairs.length;){
      let j=i; while(j<pairs.length && pairs[j][0]===pairs[i][0]) j++;
      const avg = (i + j - 1)/2 + 1;
      for(let k=i;k<j;k++) r[pairs[k][1]] = avg;
      i=j;
    }
    return r;
  };
  const ra = rank(a), rb = rank(b);
  return pearson(ra, rb);
}

function pearson(x,y){
  const n=x.length; if(!n) return 0;
  const mx=x.reduce((s,v)=>s+v,0)/n, my=y.reduce((s,v)=>s+v,0)/n;
  let num=0, dx=0, dy=0;
  for(let i=0;i<n;i++){ const a=x[i]-mx, b=y[i]-my; num+=a*b; dx+=a*a; dy+=b*b; }
  return (dx>0 && dy>0) ? num/Math.sqrt(dx*dy) : 0;
}

function kappaQuadratic(rows){
  // ratings are 0.5..5.0 in 0.5 steps → 10 categories
  const step = 0.5, base = 0.5, vmax = 5.0;
  const k = Math.round((vmax - base)/step) + 1; // =10
  const idx = v => Math.max(0, Math.min(k-1, Math.round((v - base)/step)));

  const O = Array.from({length:k},()=>Array(k).fill(0));
  for(const r of rows){ O[idx(r.a)][idx(r.b)]++; }
  const n = rows.length; if(!n) return 0;

  const R = O.map(row=>row.reduce((s,x)=>s+x,0));
  const C = Array.from({length:k},(_,j)=>O.reduce((s,row)=>s+row[j],0));
  // correct denominator uses (k-1)^2 with k=10 → (9)^2 = 81
  const denom = (k-1)*(k-1);
  const W = Array.from({length:k},(_,i)=>Array.from({length:k},(_,j)=>1 - ((i-j)*(i-j))/denom));

  const Po = (1/n) * O.reduce((S,row,i)=> S + row.reduce((s,obs,j)=> s + W[i][j]*obs, 0), 0);
  const Pe = (1/(n*n)) * W.reduce((S,row,i)=> S + row.reduce((s,wij,j)=> s + wij * R[i]*C[j], 0), 0);

  return (1-Pe) ? (Po-Pe)/(1-Pe) : 0;
}
  // === Descriptive Stats helpers ===
function meanSD(arr){
  const n = arr.length;
  if (!n) return {mean: NaN, sd: NaN};
  const m = arr.reduce((s,v)=>s+v,0)/n;
  const v = n>1 ? arr.reduce((s,v)=>{ const d=v-m; return s + d*d; }, 0) / (n-1) : NaN;
  return {mean: m, sd: (v>0?Math.sqrt(v): (n>1?0:NaN))};
}

// Student's t CDF via regularized incomplete beta
function _lnGamma(z){
  const g = 7;
  const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
             771.32342877765313, -176.61502916214059, 12.507343278686905,
             -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
  if(z < 0.5){ return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - _lnGamma(1-z); }
  z -= 1; let x = p[0]; for(let i=1;i<p.length;i++) x += p[i]/(z+i);
  const t = z + g + 0.5;
  return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x) - Math.log(z+1);
}
function _betacf(a,b,x){
  const MAXIT=200, EPS=3e-10, FPMIN=1e-30;
  let qab=a+b, qap=a+1, qam=a-1;
  let c=1, d=1 - qab*x/qap; if(Math.abs(d)<FPMIN) d=FPMIN; d=1/d; let h=d;
  for(let m=1; m<=MAXIT; m++){
    let m2=2*m;
    let aa = m*(b-m)*x/((qam+m2)*(a+m2));
    d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN; h *= d*c;
    aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
    d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN; h *= d*c;
    if(Math.abs(d*c-1) < EPS) break;
  }
  return h;
}
function _betainc(x,a,b){
  if(x<=0) return 0; if(x>=1) return 1;
  const bt = Math.exp(_lnGamma(a+b) - _lnGamma(a) - _lnGamma(b) + a*Math.log(x) + b*Math.log(1-x));
  if(x < (a+1)/(a+b+2)){ return bt * _betacf(a,b,x) / a; }
  return 1 - bt * _betacf(b,a,1-x) / b;
}
function pFromRho(r, n){
  if(!isFinite(r) || n<3) return NaN;
  const df = n - 2;
  const t = Math.abs(r) * Math.sqrt(df / Math.max(1e-12, 1 - r*r));
  const x = df / (df + t*t);
  const ib = _betainc(x, df/2, 0.5);
  const cdf = 1 - 0.5*ib; // t>=0
  const p = 2*(1 - cdf);
  return Math.max(0, Math.min(1, p));
}
function starsForP(p){
  if(!isFinite(p)) return "";
  if(p < 0.001) return "***";
  if(p < 0.01)  return "**";
  if(p < 0.05)  return "*";
  return "";
}
function pTip(p){
  if(!isFinite(p)) return "p = —";
  if(p < 0.001) return "p < .001";
  return "p = " + String(p.toFixed(3)).replace(/^0\./, ".");
}
function pKappaPermutation(rows, perms){
  const n = rows.length; if(n<5) return NaN;
  const obs = kappaQuadratic(rows);
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  let extreme = 0;
  function shuffle(x){ x=x.slice(); for(let i=x.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [x[i],x[j]]=[x[j],x[i]]; } return x; }
  const runs = perms || 10000;  // ↑ was 200–1200
  for(let r=0;r<runs;r++){
    const sb = shuffle(b);
    const k = kappaQuadratic(a.map((v,i)=>({a:v,b:sb[i]})));
    if(Math.abs(k) >= Math.abs(obs)) extreme++;
  }
  return (extreme + 1) / (runs + 1);
}
function pSpearmanPermutation(rows, perms){
  const n = rows.length; if(n<3) return NaN;
  const obs = Math.abs(spearmanRho(rows));
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  let extreme = 0;
  function sh(x){ x=x.slice(); for(let i=x.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [x[i],x[j]]=[x[j],x[i]];} return x; }
  const runs = perms || 10000;
  for(let r=0;r<runs;r++){
    const sb = sh(b);
    const rho = Math.abs(spearmanRho(a.map((v,i)=>({a:v,b:sb[i]}))));
    if(rho >= obs) extreme++;
  }
  return (extreme + 1) / (runs + 1);
}
function renderDescriptiveStats(){
  const status=$("#statusD"), tbl=$("#descTbl"), tbody=$("#descTbl tbody"), summary=$("#summaryD");
  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
    if(!lastA.length || !lastB.length){
    status.textContent = "Fetch both users.";
    tbl.hidden = true; summary.textContent="";
    const ps = $("#pairStats"); if (ps) ps.innerHTML = "";
    return;
  }
  const rows = computeOverlap();
  const nMut = rows.length;
  status.textContent="";
  const aRatingsAll = lastA.map(it=>it.rating).filter(v=>typeof v==="number");
  const bRatingsAll = lastB.map(it=>it.rating).filter(v=>typeof v==="number");
  const {mean: mA, sd: sdA} = meanSD(aRatingsAll);
  const {mean: mB, sd: sdB} = meanSD(bRatingsAll);
  const mae = nMut ? rows.reduce((s,r)=>s + Math.abs(r.a - r.b), 0)/nMut : NaN;
  const rho = nMut ? spearmanRho(rows) : NaN;
  const pRho = isFinite(rho) && nMut>=3 ? pSpearmanPermutation(rows, 10000) : NaN;
  const kq = nMut ? kappaQuadratic(rows) : NaN;
  const pK = isFinite(kq) && nMut>=5 ? pKappaPermutation(rows) : NaN;
  const fmt = (x,d=2)=> isFinite(x) ? x.toFixed(d) : "—";

// table rows: per-user n, M, SD
tbody.innerHTML = [
  `<tr><td>${aName}</td><td class="num">${aRatingsAll.length}</td><td class="num">${fmt(mA)}</td><td class="num">${fmt(sdA)}</td></tr>`,
  `<tr><td>${bName}</td><td class="num">${bRatingsAll.length}</td><td class="num">${fmt(mB)}</td><td class="num">${fmt(sdB)}</td></tr>`
].join("");

// pair lines: MAE, Spearman's ρ, Cohen's κ
const pair = $("#pairStats");
pair.innerHTML = [
  `<div>MAE = ${fmt(mae)}</div>`,
  `<div title="${pTip(pRho)}">Spearman's \u03C1 = ${fmt(rho)}${starsForP(pRho)}</div>`,
  `<div title="${pTip(pK)}">Cohen's \u03BA = ${fmt(kq)}${starsForP(pK)}</div>`
].join("");

// footer line
// summary.textContent = nMut ? `${nMut} mutual films used for MAE/ρ/κ` : "No mutual films";
tbl.hidden = false;
}
// --- Draw helpers -------------------------------------------------------------
function gridAndTicks(
  svg, W, H, m,
  xMin, xMax, yMin, yMax,
  xStep = 1, yStep = 1,
  xLabel = "", yLabel = "",
  centerXTicks = false, centerYTicks = false
){
  const x0=m.left, x1=W-m.right, y0=H-m.bottom, y1=m.top;
  const plotW = x1 - x0, plotH = y0 - y1;

  const xScale = v => x0 + ((v - xMin) / (xMax - xMin)) * plotW;
  const yScale = v => y0 - ((v - yMin) / (yMax - yMin)) * plotH;

  const xBins = Math.round((xMax - xMin)/xStep) + 1;
  const yBins = Math.round((yMax - yMin)/yStep) + 1;
  const bandX = plotW / xBins;
  const bandY = plotH / yBins;
  const xCenter = i => x0 + (i + 0.5) * bandX;
  const yCenter = j => y0 - (j + 0.5) * bandY;

  if (centerXTicks) {
    for (let i = 0; i <= xBins; i++) {
      const X = x0 + i * bandX;
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", X); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", X); ln.setAttribute("y2", y0);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  } else {
    for (let t = xMin; t <= xMax + 1e-9; t += xStep) {
      const X = xScale(t);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", X); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", X); ln.setAttribute("y2", y0);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  }

  if (centerYTicks) {
    for (let j = 0; j <= yBins; j++) {
      const Y = y0 - j * bandY;
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x0); ln.setAttribute("y1", Y);
      ln.setAttribute("x2", x1); ln.setAttribute("y2", Y);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  } else {
    for (let t = yMin; t <= yMax + 1e-9; t += yStep) {
      const Y = yScale(t);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x0); ln.setAttribute("y1", Y);
      ln.setAttribute("x2", x1); ln.setAttribute("y2", Y);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  }

  for (let i = 0; i < xBins; i++) {
    const X = centerXTicks ? xCenter(i) : xScale(xMin + i*xStep);
    const v = +(xMin + i*xStep).toFixed(1);
    const xt = document.createElementNS("http://www.w3.org/2000/svg","text");
    xt.setAttribute("x", X); xt.setAttribute("y", y0 + 22);
    xt.setAttribute("text-anchor","middle"); xt.setAttribute("class","tick");
    xt.textContent = v; svg.appendChild(xt);
  }

  for (let j = 0; j < yBins; j++) {
    const Y = centerYTicks ? yCenter(j) : yScale(yMin + j*yStep);
    const v = +(yMin + j*yStep).toFixed(1);
    const yt = document.createElementNS("http://www.w3.org/2000/svg","text");
    yt.setAttribute("x", x0 - 10); yt.setAttribute("y", Y);
    yt.setAttribute("text-anchor","end");
    yt.setAttribute("alignment-baseline","middle");
    yt.setAttribute("dominant-baseline","central");
    yt.setAttribute("class","tick");
    yt.textContent = v; svg.appendChild(yt);
  }

  const xlabel = document.createElementNS("http://www.w3.org/2000/svg","text");
  xlabel.setAttribute("x",(x0+x1)/2); xlabel.setAttribute("y", y0 + 44);
  xlabel.setAttribute("text-anchor","middle"); xlabel.setAttribute("class","tick");
  xlabel.textContent = xLabel; svg.appendChild(xlabel);

  const ylabel = document.createElementNS("http://www.w3.org/2000/svg","text");
  ylabel.setAttribute("transform",`translate(${m.left - 44} ${(y0+y1)/2}) rotate(-90)`);
  ylabel.setAttribute("text-anchor","middle"); ylabel.setAttribute("class","tick");
  ylabel.textContent = yLabel; svg.appendChild(ylabel);

  return {xScale,yScale,x0,x1,y0,y1};
}

///<script>
  
// --- Venn Diagram ---
function computeTotalsUnique(){
  const A = Array.isArray(lastA) ? lastA : [];
  const B = Array.isArray(lastB) ? lastB : [];

  const setA = new Set(A.map(filmKey).filter(Boolean));
  const setB = new Set(B.map(filmKey).filter(Boolean));

  let common = 0; for (const k of setA) if (setB.has(k)) common++;

  const totA = setA.size, totB = setB.size;

  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
  const total = totA + totB - common;
  const sum = $("#summaryV");
  if (sum) sum.textContent = `${aName} ${totA} · ${bName} ${totB} · common ${common} · total ${total}`;

  return { totA, totB, common };
}

function drawVenn(t, aName="A", bName="B"){
  const svg = $("#vennSVG"), status = $("#statusV");
  const W = 600, H = 400;
  svg.setAttribute("viewBox","0 0 600 400");
  svg.innerHTML = "";

  const {totA, totB, common} = t;
  if (!totA || !totB){ setStatus(status,"Enter two valid users."); return; }
  setStatus(status,"");

  // layout
  const m = {left:24, right:24, top:56, bottom:24};
  const boxW = W - m.left - m.right, boxH = H - m.top - m.bottom;

  // radii by area ~ counts
  let rA = Math.sqrt(totA), rB = Math.sqrt(totB);
  const s = (boxH * 0.38) / Math.max(rA, rB);
  rA *= s; rB *= s;

  // clamp for acos
  const clamp1 = v => Math.max(-1, Math.min(1, v));

  // circle–circle intersection area
  function Aint(ra, rb, d){
    if (d >= ra + rb) return 0;
    if (d <= Math.abs(ra - rb)) return Math.PI * Math.min(ra, rb) ** 2;
    const a1 = Math.acos(clamp1((d*d + ra*ra - rb*rb)/(2*d*ra)));
    const a2 = Math.acos(clamp1((d*d + rb*rb - ra*ra)/(2*d*rb)));
    return ra*ra*a1 + rb*rb*a2 - d*ra*Math.sin(a1);
  }

  // target overlap area (π·s² per film)
  const areaPerFilm = Math.PI * (rA*rA) / totA;
  const target = areaPerFilm * common;

  // solve center distance d with edge cases
  let d;
  const minD = Math.abs(rA - rB); // full containment
  const maxD = rA + rB;           // no overlap
  if (common <= 0) d = maxD;
  else if (common >= Math.min(totA, totB)) d = minD;
  else {
    let lo = minD, hi = maxD;
    for (let i=0;i<40;i++){
      const mid = 0.5*(lo+hi);
      const ai = Aint(rA, rB, mid);
      if (ai >= target) lo = mid; else hi = mid;
    }
    d = 0.5*(lo+hi);
  }

  // fit width
  const span = d + rA + rB;
  if (span > boxW){ const sf = boxW / span; rA*=sf; rB*=sf; d*=sf; }

  // centers
  const cy = m.top + boxH*0.50;
  const clusterW = d + rA + rB;
  const startX = m.left + (boxW - clusterW)/2;
  const xA = startX + rA;
  const xB = xA + d;

  // helper
  const add = (n, attrs) => { const el=document.createElementNS("http://www.w3.org/2000/svg",n);
    for (const k in attrs) el.setAttribute(k, attrs[k]); svg.appendChild(el); return el; };

  // fills
  const fillA = "#007FFF", fillB = "#bf430b", fillAB = "#ff1fab";

  // base circles
  add("circle",{cx:xA, cy, r:rA, fill:fillA});
  add("circle",{cx:xB, cy, r:rB, fill:fillB});

  // overlap lens fill
  function drawOverlapLens(cx1, r1, cx2, r2, cy, d){
    if (d >= r1 + r2) return;
    if (d <= Math.abs(r1 - r2)) {
      const cx = (r1 <= r2) ? cx1 : cx2;
      const rr = Math.min(r1, r2);
      add("circle",{cx, cy, r: rr, fill: fillAB});
      return;
    }
    const a1 = Math.acos(clamp1((d*d + r1*r1 - r2*r2)/(2*d*r1)));
    const a2 = Math.acos(clamp1((d*d + r2*r2 - r1*r1)/(2*d*r2)));
    const p1x = cx1 + r1 * Math.cos(a1),  p1y = cy - r1 * Math.sin(a1);
    const p2x = cx1 + r1 * Math.cos(-a1), p2y = cy - r1 * Math.sin(-a1);
    const q1x = cx2 + r2 * Math.cos(Math.PI - a2),  q1y = cy - r2 * Math.sin(Math.PI - a2);
    const path = [
      `M ${p1x} ${p1y}`,
      `A ${r1} ${r1} 0 0 1 ${p2x} ${p2y}`,
      `A ${r2} ${r2} 0 0 1 ${q1x} ${q1y}`,
      `A ${r1} ${r1} 0 0 0 ${p1x} ${p1y}`,
      "Z"
    ].join(" ");
    add("path",{d:path, fill:fillAB});
  }
  drawOverlapLens(xA, rA, xB, rB, cy, d);

  // union percentages
  const total = totA + totB - common;
  const uniqueA = totA - common;
  const uniqueB = totB - common;
  const pct = v => total ? Math.round(100 * v / total) : 0;

  const tip = $("#vennTip");
  function attachTip(el, textFn){
    el.addEventListener("mouseenter", ()=>{ tip.style.display="block"; tip.textContent=textFn(); });
    el.addEventListener("mousemove", e=>{
      const r = $("#vennWrap").getBoundingClientRect();
      tip.style.left = (e.clientX - r.left) + "px";
      tip.style.top  = (e.clientY - r.top)  + "px";
    });
    el.addEventListener("mouseleave", ()=>{ tip.style.display="none"; });
  }

  const fontNumPx  = Math.max(12, Math.min(18, Math.round(Math.min(rA, rB) * 0.22)));
  const fontNamePx = Math.max(12, Math.min(16, Math.round(Math.min(rA, rB) * 0.18)));
  const fontNum  = `normal ${fontNumPx}px Arial, Helvetica, sans-serif`;   // numbers (223, 110, 509)
const fontName = `normal ${fontNamePx}px Arial, Helvetica, sans-serif`;  // user labels

  const txt = (attrs, s) => { const t = add("text", attrs); t.textContent = s; return t; };
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // geometry flags
  const hasOverlap = d < rA + rB && d > Math.abs(rA - rB);
  const contained  = d <= Math.abs(rA - rB);

  // chord distances
  const safeD = Math.max(d, 1e-6);
  let aA = rA, aB = rB;
  if (hasOverlap) {
    aA = (safeD*safeD + rA*rA - rB*rB) / (2*safeD);
    aB = (safeD*safeD + rB*rB - rA*rA) / (2*safeD);
  } else if (contained) {
    aA = (rA <= rB) ? 0 : rA;
    aB = (rB <= rA) ? 0 : rB;
  }

  // unique number positions
  const uA = totA - common;
  const uB = totB - common;
  const xTotA = (uA > 0 && hasOverlap) ? xA + (aA - rA)/2 : xA;
  const xTotB = (uB > 0 && hasOverlap) ? xB + (rB - aB)/2 : xB;
  const yTotA = uA > 0 ? cy : cy - rA*0.30;
  const yTotB = uB > 0 ? cy : cy - rB*0.30;

  //THIS IS THE ORIGINAL const xLens = hasOverlap ? (xA + aA + xB - aB)/2 : (xA + xB)/2;
  //BELOW WAS THE REPLACEMENT
  const xLens = contained
  ? (rA <= rB ? xA : xB)
  : (hasOverlap ? (xA + aA + xB - aB)/2 : (xA + xB)/2);

  const leftContained  = (d <= Math.abs(rA - rB)) && (rA <= rB);
  const rightContained = (d <= Math.abs(rA - rB)) && (rB <= rA);

  /// if (!leftContained) {
  //  txt({x:xTotA, y:yTotA, "text-anchor":"middle", fill:"#000", style:`font:${fontNum};pointer-events:none`}, `${totA}`);
  //}
  //if (common > 0) {
  //  txt({x:xLens, y:cy, "text-anchor":"middle", fill:"#000", style:`font:${fontNum};pointer-events:none`}, `${common}`);
  //}
  //if (!rightContained) {
  //  txt({x:xTotB, y:yTotB, "text-anchor":"middle", fill:"#000", style:`font:${fontNum};pointer-events:none`}, `${totB}`);
  //}
  //////THE BELOW REPLACED THE ABOVE
  if (!leftContained) {
  txt({x:xTotA, y:yTotA, "text-anchor":"middle", fill:"#000", style:`font:${fontNum};pointer-events:none`}, `${totA}`);
}
if (common > 0) {
  txt({x:xLens, y:cy, "text-anchor":"middle", fill:"#000", style:`font:${fontNum};pointer-events:none`}, `${common}`);
}
if (!rightContained) {
  txt({x:xTotB, y:yTotB, "text-anchor":"middle", fill:"#000", style:`font:${fontNum};pointer-events:none`}, `${totB}`);
}

  // names
  function placeName(cx, cy, r, deg, label, anchor){
    const theta = (Math.PI/180) * deg;
    const offset = Math.max(16, r * 0.28);
    let x = cx + (r + offset) * Math.cos(theta);
    let y = cy + (r + offset) * Math.sin(theta);
    const xMin = m.left + 6, xMax = W - m.right - 6;
    const yMin = m.top + 6,  yMax = H - m.bottom - 6;
    x = clamp(x, xMin, xMax);
    y = clamp(y, yMin, yMax);
    return txt({x, y, "text-anchor": anchor, fill:"#000", style:`font:${fontName}`}, label);
  }
  const nameAEl = placeName(xA, cy, rA, -150, aName, "start");
  const nameBEl = placeName(xB, cy, rB,  -30, bName, "start");
  nameAEl.setAttribute("style", (nameAEl.getAttribute("style")||"") + ";cursor:help");
  nameBEl.setAttribute("style", (nameBEl.getAttribute("style")||"") + ";cursor:help");
  attachTip(nameAEl, ()=> `${uniqueA} unique (${pct(uniqueA)}%)`);
  attachTip(nameBEl, ()=> `${uniqueB} unique (${pct(uniqueB)}%)`);

  // hit areas
  const leftHit  = add("circle",{cx:xA, cy, r:rA, fill:"rgba(0,0,0,0.001)"});
  attachTip(leftHit,  ()=> `${uniqueA} unique (${pct(uniqueA)}%)`);
  const rightHit = add("circle",{cx:xB, cy, r:rB, fill:"rgba(0,0,0,0.001)"});
  attachTip(rightHit, ()=> `${uniqueB} unique (${pct(uniqueB)}%)`);

  // overlap hit
  (function(){
    if (d >= rA + rB) return;                       // no overlap
    if (d <= Math.abs(rA - rB)) {                   // full containment
      const cx = (rA <= rB) ? xA : xB;
      const rr = Math.min(rA, rB);
      const lensHit = add("circle",{cx, cy, r: rr, fill:"rgba(0,0,0,0.001)"});
      attachTip(lensHit, ()=> `${common} in common (${pct(common)}% of union)`);
      return;
    }
    const a1 = Math.acos(clamp1((d*d + rA*rA - rB*rB)/(2*d*rA)));
    const a2 = Math.acos(clamp1((d*d + rB*rB - rA*rA)/(2*d*rB)));
    const p1x = xA + rA * Math.cos(a1),  p1y = cy - rA * Math.sin(a1);
    const p2x = xA + rA * Math.cos(-a1), p2y = cy - rA * Math.sin(-a1);
    const q1x = xB + rB * Math.cos(Math.PI - a2),  q1y = cy - rB * Math.sin(Math.PI - a2);
    const dLens = [
      `M ${p1x} ${p1y}`,
      `A ${rA} ${rA} 0 0 1 ${p2x} ${p2y}`,
      `A ${rB} ${rB} 0 0 1 ${q1x} ${q1y}`,
      `A ${rA} ${rA} 0 0 0 ${p1x} ${p1y}`,
      "Z"
    ].join(" ");
    const lensHit = add("path",{d:dLens, fill:"rgba(0,0,0,0.001)"});
    attachTip(lensHit, ()=> `${common} in common (${pct(common)}% of union)`);
  })();
}
// --- end Venn Diagram ---



// --- Heatmap ------------------------------------------------------------------
function drawHeatmap(rows, aName="A", bName="B"){
  const svg=$("#heatSVG"), tip=$("#heatTip"), status=$("#statusM"), sum=$("#summaryM");
  const W=600, H=600, m={left:68, right:28, top:36, bottom:72};
  svg.innerHTML="";
  if(!rows || !rows.length){ setStatus(status,"No overlap yet."); sum.textContent=""; return; }
  setStatus(status,"");

  const {xScale,yScale,x0,x1,y0,y1} =
  gridAndTicks(svg, W, H, m, 0.5, 5.0, 0.5, 5.0, 0.5, 0.5, `${aName} rating`, `${bName} rating`, true, true);

  const step=0.5, base=0.5, vals=Array.from({length:10},(_,i)=>+(base + i*step).toFixed(1));

  const counts = new Map(); let maxCount=0;
  rows.forEach(r=>{
    const ax = +(Math.round(r.a/step)*step).toFixed(1);
    const by = +(Math.round(r.b/step)*step).toFixed(1);
    const k = `${ax}|${by}`;
    const v = (counts.get(k)||0) + 1;
    counts.set(k, v);
    if(v>maxCount) maxCount=v;
  });

  const bins = vals.length;
  const bandX  = (x1 - x0) / bins;
  const bandY  = (y0 - y1) / bins;
  const cellW  = bandX * 0.92;
  const cellH  = bandY * 0.92;
  const padX   = (bandX - cellW) / 2;
  const padY   = (bandY - cellH) / 2;

  function color(t){
    const v = Math.sqrt(Math.max(0,Math.min(1,t)));
    const shade = 255 - Math.round(155*v);
    return `rgb(${shade},${shade},255)`;
  }

  vals.forEach((ax, i)=>{
    vals.forEach((by, j)=>{
      const k = `${ax}|${by}`;
      const v = counts.get(k) || 0;

      const x = x0 + i * bandX + padX;
      const y = y1 + (bins - 1 - j) * bandY + padY;
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width",  cellW);
      rect.setAttribute("height", cellH);
      rect.setAttribute("fill", v ? color(v/maxCount) : "rgb(240,240,255)");
      rect.setAttribute("stroke", "#e6e6f8");
      rect.addEventListener("mouseenter",()=>{
        if(!v) return;
        tip.style.display="block";
        tip.textContent = `${aName} ${ax}★, ${bName} ${by}★ — ${v} (${Math.round(100*v/rows.length)}%)`;
      });
      rect.addEventListener("mousemove",e=>{
        const rectB = $("#heatWrap").getBoundingClientRect();
        tip.style.left=(e.clientX-rectB.left)+"px";
        tip.style.top =(e.clientY-rectB.top)+"px";
      });
      rect.addEventListener("mouseleave",()=>{ tip.style.display="none"; });
      svg.appendChild(rect);

      if(v>0 && cellW>=40 && cellH>=24){
        const t = document.createElementNS("http://www.w3.org/2000/svg","text");
        t.setAttribute("x", x + cellW/2);
        t.setAttribute("y", y + cellH/2 + 4);
        t.setAttribute("text-anchor","middle");
        t.setAttribute("class","tick");
        t.textContent = v;
        svg.appendChild(t);
      }
    });
  });
  const diag=document.createElementNS("http://www.w3.org/2000/svg","line");
  diag.setAttribute("x1", x0);
  diag.setAttribute("y1", y0);
  diag.setAttribute("x2", x1);
  diag.setAttribute("y2", y1);
  diag.setAttribute("class","diag"); svg.appendChild(diag);

}

// --- Histogram of absolute differences ---------------------------------------
function drawHistogram(rows, aName="A", bName="B"){
  const svg=$("#histSVG"), tip=$("#histTip"), status=$("#statusH"), sum=$("#summaryH");
  const W=700, H=520, m={left:68, right:28, top:36, bottom:72};
  svg.innerHTML="";
  if(!rows || !rows.length){ setStatus(status,"No overlap yet."); sum.textContent=""; return; }
  setStatus(status,"");

  const step = 0.5;
  const bins = Array.from({length:10}, (_,i) => +(i*step).toFixed(1)); // 0..4.5
  const counts = new Array(bins.length).fill(0);
  rows.forEach(r => { const d = Math.abs(r.a - r.b); const idx = Math.round(d/step); if(idx >= 0 && idx < counts.length) counts[idx]++; });
  const n = rows.length;
  const props = counts.map(c => (100*c/n));
  const maxPct  = Math.max(...props, 0);
  const yMaxDyn = Math.min(100, Math.max(10, Math.ceil(maxPct/10)*10));
    sum.textContent = `Exact ${props[0].toFixed(0)}% · ≤0.5★ ${(props[0]+props[1]).toFixed(0)}% · ≤1★ ${(props[0]+props[1]+props[2]).toFixed(0)}%`;

  const {xScale,yScale,x0,x1,y0,y1} =
  gridAndTicks(svg, W, H, m,
    0, 4.5,
    0, yMaxDyn,
    0.5, 10,
    `|${aName}−${bName}| (★)`, "Share of titles (%)",
    true, false);

  const band = (x1 - x0) / bins.length;
  const barW = band * 0.72;

  bins.forEach((b, i) => {
    const v = props[i];
    const x = x0 + i * band + (band - barW) / 2;
    const y = yScale(v);
    const h = yScale(0) - y;

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", x); rect.setAttribute("y", y);
    rect.setAttribute("width", barW); rect.setAttribute("height", Math.max(0, h));
    rect.setAttribute("fill", "#666666");
    rect.setAttribute("stroke", "#e0e0e0");
    rect.addEventListener("mouseenter", ()=>{ tip.style.display="block"; tip.textContent = `|${aName}−${bName}| = ${b}★ → ${v.toFixed(1)}% (${counts[i]} films)`; });
    rect.addEventListener("mousemove", e=>{ const rectW=$("#histWrap").getBoundingClientRect(); tip.style.left=(e.clientX-rectW.left)+"px"; tip.style.top=(e.clientY-rectW.top)+"px";});
    rect.addEventListener("mouseleave", ()=>{ tip.style.display="none"; });
    svg.appendChild(rect);

    if(v >= 0.5){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", x + barW/2); t.setAttribute("y", y - 6);
      t.setAttribute("text-anchor", "middle"); t.setAttribute("class","tick");
      t.textContent = v.toFixed(0) + "%";
      svg.appendChild(t);
    }
  });
}

// --- Orchestration ------------------------------------------------------------
function updateAllViews(){
  const rows = computeOverlap();

  const status=$("#statusO"), tbl=$("#tblO"), tbody=$("#tblO tbody"), summary=$("#summaryO"), statsEl=$("#stats");
  if(!rows.length){
    setStatus(status,"Fetch both to see overlaps.");
    tbl.hidden=true; summary.textContent=""; statsEl.textContent="";
  } else {
    setStatus(status,""); summary.textContent=`${rows.length} films in common`;
    tbody.innerHTML = rows.map(r=>`<tr><td>${r.title}</td><td class="num">${r.a.toFixed(1)}</td><td class="num">${r.b.toFixed(1)}</td></tr>`).join("");
    tbl.hidden=false;
    const s = calcStats(rows);
    const rho = spearmanRho(rows);
    const kq  = kappaQuadratic(rows);
      statsEl.textContent =
      `Exact ${s.pct0.toFixed(0)}% · ≤0.5★ ${s.pct05.toFixed(0)}% · ≤1★ ${s.pct10.toFixed(0)}% ` +
      `· Bias (A−B): ${s.meanBias.toFixed(2)}★ · MAE: ${s.mae.toFixed(2)}★ · Spearman's ρ: ${rho.toFixed(2)} · Cohen's κ: ${kq.toFixed(2)}`;
  }

  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
  drawVenn(computeTotalsUnique(), aName, bName);
  drawHeatmap(rows, aName, bName);
  drawHistogram(rows, aName, bName);
  renderDescriptiveStats(); 
}

async function runBoth(){
  const status = $("#statusO");
  const uA = normUser($("#userA").value);
  const uB = normUser($("#userB").value);
  if(!uA || !uB){ setStatus(status,"Enter two valid usernames.", true); return; }
  
  showLoadingBar();
  try{
    const [a, b] = await Promise.all([fetchRatings(uA), fetchRatings(uB)]);
    lastA = a.items || [];
    lastB = b.items || [];
    setStatus(status,"");
    updateAllViews();
    hideLoadingBar();
  }catch(e){
    setStatus(status, e.message || String(e), true);
    hideLoadingBar();
    lastA = []; lastB = [];
    updateAllViews();
  }
}

$("#userA").addEventListener("keydown", e => { if(e.key==="Enter"){ e.preventDefault(); runBoth(); }});
$("#userB").addEventListener("keydown", e => { if(e.key==="Enter"){ e.preventDefault(); runBoth(); }});
</script>
</body>
</html>
