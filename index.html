<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Matchboxd by eddıe</title>
  <link rel="preload" href="./assets/fonts/Inter-Regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="./assets/fonts/Inter-Bold.woff2" as="font" type="font/woff2" crossorigin>
<style>
  @font-face{
  font-family:"Inter";
  src:url("./assets/fonts/Inter-Regular.woff2") format("woff2");
  font-weight:400;
  font-style:normal;
  font-display:swap;
}
@font-face{
  font-family:"Inter";
  src:url("./assets/fonts/Inter-Bold.woff2") format("woff2");
  font-weight:700;
  font-style:normal;
  font-display:swap;
}
:root { --bg:#0e141b; --fg:#c8d0d9; --muted:#8fa0ad; --grid:#1f2a35; --accent:#7dd3fc; --accent2:#a7f3d0; }
* { box-sizing: border-box; }
body { margin:0; font-family:"Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background:var(--bg); color:var(--fg);}
header { padding:16px; border-bottom:1px solid var(--grid); display:flex; align-items:center; justify-content:space-between; gap:12px;}
header h1 { font-size:18px; margin:0;}
.top-actions { display:flex; gap:8px; align-items:center; }
/* Softer, pill-style inputs (Amazon/Google-like) */
.top-actions input[type=text]{
  width:clamp(200px,26vw,320px);
  padding:10px 14px;
  border:1px solid #D4DAE2;
  background:#F6F8FB;       /* off-white to avoid harsh contrast */
  color:#0A0F14;
  border-radius:9999px;      /* pill */
  line-height:1.2;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.6), 0 1px 2px rgba(12,20,28,.08);
  transition:border-color .15s ease, background-color .15s ease, box-shadow .15s ease;
  outline:0;
}
.top-actions input[type=text]::placeholder{
  color:#8893A3;             /* soft gray like examples */
  opacity:1;
}
.top-actions input[type=text]:hover{
  border-color:#B8C1CC;
  background:#F9FAFC;
}
.top-actions input[type=text]:focus{
  border-color:#007FFF;      /* your brand blue */
  background:#FFFFFF;
  box-shadow:0 0 0 3px rgba(0,127,255,.15), inset 0 1px 0 rgba(255,255,255,.6);
  outline:0;
}
@media (max-width:560px){
  .top-actions input[type=text]{ width:100%; max-width:none; }
}
.top-actions input::placeholder{ color:#6a7b89;}


main { max-width:1620px; margin:24px auto; padding:0 16px 48px;}
.grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:16px; }
.card { background:#111922; border:1px solid var(--grid); border-radius:12px; padding:16px; box-shadow:0 1px 10px #0006;}
label { display:block; font-size:14px; color:var(--muted); margin-bottom:6px;}
.row{ display:flex; gap:8px; align-items:flex-end; }
.status{ margin-top:8px; color:var(--muted); min-height:1.4em;}
.small{ font-size:12px; color:var(--muted);}
table{ width:100%; border-collapse:collapse; margin-top:12px;}
th,td{ padding:10px 8px; border-bottom:1px solid var(--grid); font-size:14px;}
  /* sortable table header buttons */
.sort-btn{
  all:unset;
  cursor:pointer;
  font:inherit;
  color:var(--muted);
  display:inline-flex;
  align-items:center;
  gap:6px;
}
.sort-btn.sorted{ color:#c8d0d9; }
.sort-btn .arrow{ font-size:10px; opacity:.85; }

.avatar-24{
  width:24px; height:24px; border-radius:50%;
  object-fit:cover; display:inline-block; vertical-align:middle;
  border:1px solid rgba(255,255,255,.08);
}  
  
th{ text-align:left; color:var(--muted); font-weight:600;}
.num{ text-align:right; font-variant-numeric: tabular-nums;}
footer{ color:#6a7b89; text-align:center; font-size:12px; padding:12px 0 32px;}

/* SVGs – APA Style */
.svg { width:100%; height:420px; display:block; background:#ffffff; }
.tick text { fill:#000000; font-size:13px; font-family:"Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
.gridline{ stroke:#cccccc; stroke-width:1; }
.diag{ stroke:#666666; stroke-dasharray:4 4; }
.tooltip{
  position:absolute; pointer-events:none;
  left:0; top:0;                       /* JS sets final x/y */
  transform:none;                      /* no auto shift */
  background:#111922; border:1px solid #2a3745; border-radius:8px;
  padding:6px 10px; font-size:12px; color:#c8d0d9;
  font-family:"Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  white-space:nowrap; box-shadow:0 4px 16px rgba(0,0,0,.35);
  display:none; z-index:20;
}
#heatWrap, #histWrap, #watchWrap { position:relative; width:100%; }
.legend {
  display:flex;
  flex-wrap: wrap;
  gap:8px 12px;
  align-items:center;
  font-size:12px;
  color:#000000;
    font-family:"Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  margin-top:8px;
}
.swatch { width:12px; height:12px; border-radius:2px; }

/* Prevent mobile zoom on inputs/buttons */
input, button, select, textarea { font-size: 16px !important; }
/* Stack header across all sizes */
header { display:flex; flex-direction: column; align-items:center; gap:12px; text-align:center; }
.top-actions { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
@media (max-width: 560px){
.top-actions{ flex-direction:column; align-items:stretch; }
.top-actions input[type=text] { width:100%; }
}
/* === Loading bar (viewport sweep) === */
.loading-bar{
  position:fixed; top:0; left:0; right:0; height:4px;
  background: transparent; margin:0; border-radius:0; overflow:hidden;
  z-index:9999; pointer-events:none;
}
.loading-bar-indeterminate{
  position:absolute; top:0; bottom:0;
  left:-20%; width:18%; min-width:120px;
  background:linear-gradient(90deg,#007FFF 0%,#ff1fab 60%,#bf430b 100%);
  animation:lb-sweep 1.15s cubic-bezier(.4,0,.2,1) infinite;
}
@keyframes lb-sweep{ 0%{ left:-20%; } 100%{ left:100%; } }
  #panelD .stats-lines div{ margin-top:4px; }

/* By-Year bars + interactions */
.year-svg { width:100%; height:220px; }
.bar { pointer-events:none; } /* let the hit band take events */
.hit { cursor:pointer; touch-action:pan-y; pointer-events:all; }
.bar:hover { opacity:.9 }
#panelY { position:relative; } /* tooltip positioning context */

/* Ratings animation panel */
#panelS { position:relative; }
#starAnimWrap { margin-top:4px; }
.star-row{
  display:flex;
  align-items:flex-end;
  gap:8px;
  margin-top:8px;
}
.star-user-label{
  width:72px;
  font-size:12px;
  color:var(--muted);
}
.star-bars{
  flex:1;
  display:flex;
  align-items:flex-end;
  gap:4px;
  height:72px;
}
.star-bar{
  flex:1;
  border-radius:3px 3px 0 0;
  /* same blue → pink → orange palette as the year bars */
  background:linear-gradient(180deg,#007FFF 0%,#ff1fab 50%,#bf430b 100%);
  min-height:3%;
  transition:height .12s ease-out;
}
.star-progress{
  margin-top:4px;
}
#starReplay{
  margin-top:8px;
  padding:6px 14px;
  border-radius:9999px;
  border:1px solid var(--grid);
  background:#1f2933;
  color:var(--fg);
  font-size:12px;
  cursor:pointer;
}
#starReplay:hover{
  background:#253341;
}
  
</style>
</head>
<body>
<header>
<h1>Matchboxd by eddıe</h1>
<div class="top-actions">
<input id="userA" type="text" autocapitalize="none" autocomplete="off" placeholder="e.g., eddieslb" />
<input id="userB" type="text" autocapitalize="none" autocomplete="off" placeholder="e.g., steedmanson" />

</div>
</header>

<main>
  <div id="loadingBar" class="loading-bar" hidden aria-live="polite">
  <div class="loading-bar-indeterminate"></div>
</div>
<div class="grid">

<!-- Ratings Animation panel -->
<section class="card" id="panelS">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Ratings Animation</label>
    <div class="small" id="summaryS"></div>
  </div>
  <div id="statusS" class="status"></div>
  <div id="starAnimWrap">
    <div class="star-row">
      <div class="star-user-label" id="starUserA">User A</div>
      <div class="star-bars" id="starBarsA"></div>
    </div>
    <div class="small star-progress" id="starProgressA"></div>

    <div class="star-row">
      <div class="star-user-label" id="starUserB">User B</div>
      <div class="star-bars" id="starBarsB"></div>
    </div>
    <div class="small star-progress" id="starProgressB"></div>

    <button id="starReplay" type="button">Replay</button>
  </div>
</section>

<!-- By Year panel -->
<section class="card" id="panelY">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>By Year</label>
    <div class="small" id="summaryY"></div>
  </div>
  <div id="statusY" class="status"></div>
  <svg id="yearA" class="svg year-svg" viewBox="0 0 1200 220" aria-label="User A by year"></svg>
  <svg id="yearB" class="svg year-svg" viewBox="0 0 1200 220" aria-label="User B by year" style="margin-top:12px"></svg>
  <div id="yearTip" class="tooltip"></div>
</section>


<!-- Venn Diagram panel -->
<section class="card" id="panelV">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Venn Diagram</label>
    
  </div>
  <div id="statusV" class="status"></div>
  <div id="vennWrap" style="position:relative;width:100%;">
  <svg id="vennSVG" class="svg" viewBox="0 0 600 400"></svg>
  <div id="vennTip" class="tooltip"></div>
</div>
</section>
  
  
<section class="card" id="panelM">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Match Matrix</label>
<div class="small" id="summaryM"></div>
</div>
<div id="statusM" class="status"></div>
<div id="heatWrap">
<svg id="heatSVG" class="svg" viewBox="0 0 600 600"></svg>
<div id="heatTip" class="tooltip"></div>
</div>

</section>

<section class="card" id="panelH">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Agreement Graph</label>
<div class="small" id="summaryH"></div>
</div>
<div id="statusH" class="status"></div>
<div id="histWrap">
<svg id="histSVG" class="svg" viewBox="0 0 700 500"></svg>
<div id="histTip" class="tooltip"></div>
</div>
</section>

  <section class="card" id="panelT">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Total Hours Logged</label>
    <div class="small" id="summaryT"></div>
  </div>
  <div id="statusT" class="status"></div>
  <div id="watchWrap">
    <svg id="watchSVG" class="svg" viewBox="0 0 700 320" aria-label="Total hours logged per user"></svg>
    <div id="watchTip" class="tooltip"></div>
  </div>
</section>


<!-- NEW: Descriptive Statistics -->
<section class="card" id="panelD">
  <div class="row" style="justify-content:space-between; align-items:center">
    <label>Descriptive Statistics</label>
    <div class="small" id="summaryD"></div>
  </div>
  <div id="statusD" class="status"></div>
    <table id="descTbl">
    <thead>
      <tr>
        <th>User</th>
        <th class="num">n</th>
        <th class="num">M</th>
        <th class="num">SD</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="pairStats" class="small stats-lines"></div>
  <div class="small" id="p-legend">* p &lt; .05, ** p &lt; .01, *** p &lt; .001</div>
</section>

<section class="card" id="panelO">
<div class="row" style="justify-content:space-between; align-items:center">
<label>Mutual Movies</label>
<div class="small" id="summaryO"></div>
</div>
<div id="statusO" class="status"></div>
  
<table id="tblO" hidden>
  <thead>
    <tr>
      <th style="width:60%">
        <button class="sort-btn" data-key="title" aria-label="Sort by title">
          Title <span class="arrow"></span>
        </button>
      </th>
      <th class="num" style="width:20%">
        <button class="sort-btn" data-key="a" aria-label="Sort by A's rating">
          <img id="hdrA" class="avatar-24" src="" alt="A"><span class="arrow"></span>
        </button>
      </th>
      <th class="num" style="width:20%">
        <button class="sort-btn" data-key="b" aria-label="Sort by B's rating">
          <img id="hdrB" class="avatar-24" src="" alt="B"><span class="arrow"></span>
        </button>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>
  
<div class="small" id="stats"></div>
</section>
</div>

<footer>Not affiliated with Letterboxd</footer>
</main>

<script>
function showLoadingBar(){ document.getElementById("loadingBar").hidden = false; }
function hideLoadingBar(){ document.getElementById("loadingBar").hidden = true; }
const $ = (s, r=document) => r.querySelector(s);

// --- Fetch -------------------------------------------------------------------
function normUser(u){ if(!u) return null; u=String(u).trim().replace(/^@/,"").toLowerCase(); return /^[a-z0-9_-]{1,30}$/i.test(u)?u:null; }
async function fetchRatings(user){
  const res = await fetch(`/api/ratings?user=${encodeURIComponent(user)}`, {headers:{Accept:"application/json"}});
  if(!res.ok) throw new Error(`API ${res.status}`); return res.json();
}
  async function fetchDiary(user, maxPages=50){
  const r = await fetch(`/api/diary?user=${encodeURIComponent(user)}&maxPages=${maxPages}`);
  if(!r.ok) throw new Error(`Diary fetch failed for ${user}`);
  return r.json();
}
  async function fetchWatchtime(user, maxPages=200){
  const r = await fetch(`/api/watchtime?user=${encodeURIComponent(user)}&maxPages=${maxPages}`, { headers:{Accept:"application/json"} });
  if(!r.ok) throw new Error(`Watchtime fetch failed for ${user}`);
  return r.json();
}

function setStatus(el,msg,isErr=false){ el.textContent = msg||""; el.style.color = isErr ? "#ffb3b3" : "#8fa0ad"; }

// --- Shared state + overlap ---------------------------------------------------
let lastA = [], lastB = [];
let diaryA = null, diaryB = null; let watchA = 0, watchB = 0; // per-year counts for each user

// Unique identity key for a film: prefer slug, then url, then title+year
const filmKey = it => {
  if (!it) return null;
  if (it.slug) return String(it.slug).toLowerCase();
  if (it.url) {
    const m = it.url.match(/\/film\/([^/]+)\//);
    return (m ? m[1] : it.url).toLowerCase();
  }
  const t = (it.title||"").normalize("NFKD").toLowerCase().replace(/\s+/g," ").trim();
  const y = it.year ? String(it.year) : "";
  return `${t}|${y}`;
};

function computeOverlap(){
  const mapA = new Map(), mapB = new Map();
  const meta = new Map(); // k -> { title, year }

  for (const it of lastA) {
    if (!it?.title) continue;
    const k = filmKey(it);
    mapA.set(k, it.rating);
    const m = meta.get(k) || { title: it.title, year: null };
    if (!m.title && it.title) m.title = it.title;
    if (!m.year && it.year) m.year = it.year;
    meta.set(k, m);
  }

  for (const it of lastB) {
    if (!it?.title) continue;
    const k = filmKey(it);
    mapB.set(k, it.rating);
    const m = meta.get(k) || { title: it.title, year: null };
    if (!m.title && it.title) m.title = it.title;
    if (!m.year && it.year) m.year = it.year;
    meta.set(k, m);
  }

  const rows = [];
  for (const [k, ra] of mapA.entries()) {
    if (mapB.has(k)) {
      const m = meta.get(k) || {};
      const name = m.year ? `${m.title} (${m.year})` : (m.title || "Untitled");
      rows.push({ title: name, a: ra, b: mapB.get(k) });
    }
  }
  rows.sort((x,y)=>x.title.localeCompare(y.title,'en',{sensitivity:'base'}));
  return rows;
}

function calcStats(rows){
  const n = rows.length; if(!n) return {n:0};
  const diffs = rows.map(r=>r.a-r.b);
  const abs = diffs.map(d=>Math.abs(d));
  const mean = diffs.reduce((s,d)=>s+d,0)/n;
  const mae  = abs.reduce((s,d)=>s+d,0)/n;
  const pct0  = (abs.filter(d=>d===0).length/n)*100;
  const pct05 = (abs.filter(d=>d<=0.5).length/n)*100;
  const pct10 = (abs.filter(d=>d<=1.0).length/n)*100;
  const ax = rows.map(r=>r.a), by = rows.map(r=>r.b);
  const meanA = ax.reduce((s,x)=>s+x,0)/n, meanB = by.reduce((s,x)=>s+x,0)/n;
  let num=0, denA=0, denB=0;
  for(let i=0;i<n;i++){ const da=ax[i]-meanA, db=by[i]-meanB; num+=da*db; denA+=da*da; denB+=db*db; }
  const r = (denA>0 && denB>0) ? (num/Math.sqrt(denA*denB)) : 0;
  return {n, meanBias:mean, mae, pct0, pct05, pct10, r};
}

// --- Similarity / Agreement metrics ------------------------------------------
function spearmanRho(rows){
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  const rank = arr => {
    const pairs = arr.map((v,i)=>[v,i]).sort((x,y)=>x[0]-y[0]);
    const r = Array(arr.length);
    for(let i=0;i<pairs.length;){
      let j=i; while(j<pairs.length && pairs[j][0]===pairs[i][0]) j++;
      const avg = (i + j - 1)/2 + 1;
      for(let k=i;k<j;k++) r[pairs[k][1]] = avg;
      i=j;
    }
    return r;
  };
  const ra = rank(a), rb = rank(b);
  return pearson(ra, rb);
}

function pearson(x,y){
  const n=x.length; if(!n) return 0;
  const mx=x.reduce((s,v)=>s+v,0)/n, my=y.reduce((s,v)=>s+v,0)/n;
  let num=0, dx=0, dy=0;
  for(let i=0;i<n;i++){ const a=x[i]-mx, b=y[i]-my; num+=a*b; dx+=a*a; dy+=b*b; }
  return (dx>0 && dy>0) ? num/Math.sqrt(dx*dy) : 0;
}

function kappaQuadratic(rows){
  // ratings are 0.5..5.0 in 0.5 steps → 10 categories
  const step = 0.5, base = 0.5, vmax = 5.0;
  const k = Math.round((vmax - base)/step) + 1; // =10
  const idx = v => Math.max(0, Math.min(k-1, Math.round((v - base)/step)));

  const O = Array.from({length:k},()=>Array(k).fill(0));
  for(const r of rows){ O[idx(r.a)][idx(r.b)]++; }
  const n = rows.length; if(!n) return 0;

  const R = O.map(row=>row.reduce((s,x)=>s+x,0));
  const C = Array.from({length:k},(_,j)=>O.reduce((s,row)=>s+row[j],0));
  // correct denominator uses (k-1)^2 with k=10 → (9)^2 = 81
  const denom = (k-1)*(k-1);
  const W = Array.from({length:k},(_,i)=>Array.from({length:k},(_,j)=>1 - ((i-j)*(i-j))/denom));

  const Po = (1/n) * O.reduce((S,row,i)=> S + row.reduce((s,obs,j)=> s + W[i][j]*obs, 0), 0);
  const Pe = (1/(n*n)) * W.reduce((S,row,i)=> S + row.reduce((s,wij,j)=> s + wij * R[i]*C[j], 0), 0);

  return (1-Pe) ? (Po-Pe)/(1-Pe) : 0;
}
  // === Descriptive Stats helpers ===
function meanSD(arr){
  const n = arr.length;
  if (!n) return {mean: NaN, sd: NaN};
  const m = arr.reduce((s,v)=>s+v,0)/n;
  const v = n>1 ? arr.reduce((s,v)=>{ const d=v-m; return s + d*d; }, 0) / (n-1) : NaN;
  return {mean: m, sd: (v>0?Math.sqrt(v): (n>1?0:NaN))};
}

// Student's t CDF via regularized incomplete beta
function _lnGamma(z){
  const g = 7;
  const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
             771.32342877765313, -176.61502916214059, 12.507343278686905,
             -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
  if(z < 0.5){ return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - _lnGamma(1-z); }
  z -= 1; let x = p[0]; for(let i=1;i<p.length;i++) x += p[i]/(z+i);
  const t = z + g + 0.5;
  return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x) - Math.log(z+1);
}
function _betacf(a,b,x){
  const MAXIT=200, EPS=3e-10, FPMIN=1e-30;
  let qab=a+b, qap=a+1, qam=a-1;
  let c=1, d=1 - qab*x/qap; if(Math.abs(d)<FPMIN) d=FPMIN; d=1/d; let h=d;
  for(let m=1; m<=MAXIT; m++){
    let m2=2*m;
    let aa = m*(b-m)*x/((qam+m2)*(a+m2));
    d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN; h *= d*c;
    aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
    d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN; h *= d*c;
    if(Math.abs(d*c-1) < EPS) break;
  }
  return h;
}
function _betainc(x,a,b){
  if(x<=0) return 0; if(x>=1) return 1;
  const bt = Math.exp(_lnGamma(a+b) - _lnGamma(a) - _lnGamma(b) + a*Math.log(x) + b*Math.log(1-x));
  if(x < (a+1)/(a+b+2)){ return bt * _betacf(a,b,x) / a; }
  return 1 - bt * _betacf(b,a,1-x) / b;
}
function pFromRho(r, n){
  if(!isFinite(r) || n<3) return NaN;
  const df = n - 2;
  const t = Math.abs(r) * Math.sqrt(df / Math.max(1e-12, 1 - r*r));
  const x = df / (df + t*t);
  const ib = _betainc(x, df/2, 0.5);
  const cdf = 1 - 0.5*ib; // t>=0
  const p = 2*(1 - cdf);
  return Math.max(0, Math.min(1, p));
}
function starsForP(p){
  if(!isFinite(p)) return "";
  if(p < 0.001) return "***";
  if(p < 0.01)  return "**";
  if(p < 0.05)  return "*";
  return "";
}
function pTip(p){
  if(!isFinite(p)) return "p = —";
  if(p < 0.001) return "p < .001";
  return "p = " + String(p.toFixed(3)).replace(/^0\./, ".");
}
function pKappaPermutation(rows, perms){
  const n = rows.length; if(n<5) return NaN;
  const obs = kappaQuadratic(rows);
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  let extreme = 0;
  function shuffle(x){ x=x.slice(); for(let i=x.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [x[i],x[j]]=[x[j],x[i]]; } return x; }
  const runs = perms || 10000;  // ↑ was 200–1200
  for(let r=0;r<runs;r++){
    const sb = shuffle(b);
    const k = kappaQuadratic(a.map((v,i)=>({a:v,b:sb[i]})));
    if(Math.abs(k) >= Math.abs(obs)) extreme++;
  }
  return (extreme + 1) / (runs + 1);
}
function pSpearmanPermutation(rows, perms){
  const n = rows.length; if(n<3) return NaN;
  const obs = Math.abs(spearmanRho(rows));
  const a = rows.map(r=>r.a), b = rows.map(r=>r.b);
  let extreme = 0;
  function sh(x){ x=x.slice(); for(let i=x.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [x[i],x[j]]=[x[j],x[i]];} return x; }
  const runs = perms || 10000;
  for(let r=0;r<runs;r++){
    const sb = sh(b);
    const rho = Math.abs(spearmanRho(a.map((v,i)=>({a:v,b:sb[i]}))));
    if(rho >= obs) extreme++;
  }
  return (extreme + 1) / (runs + 1);
}
function renderDescriptiveStats(){
  const status=$("#statusD"), tbl=$("#descTbl"), tbody=$("#descTbl tbody"), summary=$("#summaryD");
  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
    if(!lastA.length || !lastB.length){
    status.textContent = "Fetch both users.";
    tbl.hidden = true; summary.textContent="";
    const ps = $("#pairStats"); if (ps) ps.innerHTML = "";
    return;
  }
  const rows = computeOverlap();
  const nMut = rows.length;
  status.textContent="";
  const aRatingsAll = lastA.map(it=>it.rating).filter(v=>typeof v==="number");
  const bRatingsAll = lastB.map(it=>it.rating).filter(v=>typeof v==="number");
  const {mean: mA, sd: sdA} = meanSD(aRatingsAll);
  const {mean: mB, sd: sdB} = meanSD(bRatingsAll);
  const mae = nMut ? rows.reduce((s,r)=>s + Math.abs(r.a - r.b), 0)/nMut : NaN;
  const rho = nMut ? spearmanRho(rows) : NaN;
  const pRho = isFinite(rho) && nMut>=3 ? pSpearmanPermutation(rows, 10000) : NaN;
  const kq = nMut ? kappaQuadratic(rows) : NaN;
  const pK = isFinite(kq) && nMut>=5 ? pKappaPermutation(rows) : NaN;
  const fmt = (x,d=2)=> isFinite(x) ? x.toFixed(d) : "—";

// table rows: per-user n, M, SD
tbody.innerHTML = [
  `<tr><td>${aName}</td><td class="num">${aRatingsAll.length}</td><td class="num">${fmt(mA)}</td><td class="num">${fmt(sdA)}</td></tr>`,
  `<tr><td>${bName}</td><td class="num">${bRatingsAll.length}</td><td class="num">${fmt(mB)}</td><td class="num">${fmt(sdB)}</td></tr>`
].join("");

// pair lines: MAE, Spearman's ρ, Cohen's κ
const pair = $("#pairStats");
pair.innerHTML = [
  `<div>MAE = ${fmt(mae)}</div>`,
  `<div title="${pTip(pRho)}">Spearman's \u03C1 = ${fmt(rho)}${starsForP(pRho)}</div>`,
  `<div title="${pTip(pK)}">Cohen's \u03BA = ${fmt(kq)}${starsForP(pK)}</div>`
].join("");

// footer line
// summary.textContent = nMut ? `${nMut} mutual films used for MAE/ρ/κ` : "No mutual films";
tbl.hidden = false;
}
// --- Draw helpers -------------------------------------------------------------
function gridAndTicks(
  svg, W, H, m,
  xMin, xMax, yMin, yMax,
  xStep = 1, yStep = 1,
  xLabel = "", yLabel = "",
  centerXTicks = false, centerYTicks = false
){
  const x0=m.left, x1=W-m.right, y0=H-m.bottom, y1=m.top;
  const plotW = x1 - x0, plotH = y0 - y1;

  const xScale = v => x0 + ((v - xMin) / (xMax - xMin)) * plotW;
  const yScale = v => y0 - ((v - yMin) / (yMax - yMin)) * plotH;

  const xBins = Math.round((xMax - xMin)/xStep) + 1;
  const yBins = Math.round((yMax - yMin)/yStep) + 1;
  const bandX = plotW / xBins;
  const bandY = plotH / yBins;
  const xCenter = i => x0 + (i + 0.5) * bandX;
  const yCenter = j => y0 - (j + 0.5) * bandY;

  if (centerXTicks) {
    for (let i = 0; i <= xBins; i++) {
      const X = x0 + i * bandX;
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", X); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", X); ln.setAttribute("y2", y0);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  } else {
    for (let t = xMin; t <= xMax + 1e-9; t += xStep) {
      const X = xScale(t);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", X); ln.setAttribute("y1", y1);
      ln.setAttribute("x2", X); ln.setAttribute("y2", y0);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  }

  if (centerYTicks) {
    for (let j = 0; j <= yBins; j++) {
      const Y = y0 - j * bandY;
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x0); ln.setAttribute("y1", Y);
      ln.setAttribute("x2", x1); ln.setAttribute("y2", Y);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  } else {
    for (let t = yMin; t <= yMax + 1e-9; t += yStep) {
      const Y = yScale(t);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", x0); ln.setAttribute("y1", Y);
      ln.setAttribute("x2", x1); ln.setAttribute("y2", Y);
      ln.setAttribute("class","gridline"); ln.setAttribute("opacity","0.6");
      svg.appendChild(ln);
    }
  }

  for (let i = 0; i < xBins; i++) {
    const X = centerXTicks ? xCenter(i) : xScale(xMin + i*xStep);
    const v = +(xMin + i*xStep).toFixed(1);
    const xt = document.createElementNS("http://www.w3.org/2000/svg","text");
    xt.setAttribute("x", X); xt.setAttribute("y", y0 + 22);
    xt.setAttribute("text-anchor","middle"); xt.setAttribute("class","tick");
    xt.textContent = v; svg.appendChild(xt);
  }

  for (let j = 0; j < yBins; j++) {
    const Y = centerYTicks ? yCenter(j) : yScale(yMin + j*yStep);
    const v = +(yMin + j*yStep).toFixed(1);
    const yt = document.createElementNS("http://www.w3.org/2000/svg","text");
    yt.setAttribute("x", x0 - 10); yt.setAttribute("y", Y);
    yt.setAttribute("text-anchor","end");
    yt.setAttribute("alignment-baseline","middle");
    yt.setAttribute("dominant-baseline","central");
    yt.setAttribute("class","tick");
    yt.textContent = v; svg.appendChild(yt);
  }

  const xlabel = document.createElementNS("http://www.w3.org/2000/svg","text");
  xlabel.setAttribute("x",(x0+x1)/2); xlabel.setAttribute("y", y0 + 44);
  xlabel.setAttribute("text-anchor","middle"); xlabel.setAttribute("class","tick");
  xlabel.textContent = xLabel; svg.appendChild(xlabel);

  const ylabel = document.createElementNS("http://www.w3.org/2000/svg","text");
  ylabel.setAttribute("transform",`translate(${m.left - 44} ${(y0+y1)/2}) rotate(-90)`);
  ylabel.setAttribute("text-anchor","middle"); ylabel.setAttribute("class","tick");
  ylabel.textContent = yLabel; svg.appendChild(ylabel);

  return {xScale,yScale,x0,x1,y0,y1};
}

  
// --- Venn Diagram ---
function computeTotalsUnique(){
  const A = Array.isArray(lastA) ? lastA : [];
  const B = Array.isArray(lastB) ? lastB : [];

  const setA = new Set(A.map(filmKey).filter(Boolean));
  const setB = new Set(B.map(filmKey).filter(Boolean));

  let common = 0; for (const k of setA) if (setB.has(k)) common++;

  const totA = setA.size, totB = setB.size;

  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
  const total = totA + totB - common;
  const sum = $("#summaryV");
if (sum) sum.textContent = "";

  return { totA, totB, common };
}

function drawVenn(t, aName="A", bName="B"){
  const svg = $("#vennSVG"), status = $("#statusV");
  const W = 600, H = 400;
  svg.setAttribute("viewBox","0 0 600 400");
  svg.innerHTML = "";

  const {totA, totB, common} = t;
  if (!totA || !totB){ setStatus(status,"Enter two valid users."); return; }
  setStatus(status,"");

  const m = {left:24, right:24, top:56, bottom:24};
  const boxW = W - m.left - m.right, boxH = H - m.top - m.bottom;

  let rA = Math.sqrt(totA), rB = Math.sqrt(totB);
  const s = (boxH * 0.38) / Math.max(rA, rB);
  rA *= s; rB *= s;

  const clamp1 = v => Math.max(-1, Math.min(1, v));
  function Aint(ra, rb, d){
    if (d >= ra + rb) return 0;
    if (d <= Math.abs(ra - rb)) return Math.PI * Math.min(ra, rb) ** 2;
    const a1 = Math.acos(clamp1((d*d + ra*ra - rb*rb)/(2*d*ra)));
    const a2 = Math.acos(clamp1((d*d + rb*rb - ra*ra)/(2*d*rb)));
    return ra*ra*a1 + rb*rb*a2 - d*ra*Math.sin(a1);
  }

  let d;
  const minD = Math.abs(rA - rB), maxD = rA + rB;
  if (common <= 0) d = maxD;
  else if (common >= Math.min(totA, totB)) d = minD;
  else { let lo=minD, hi=maxD; for(let i=0;i<40;i++){ const mid=(lo+hi)/2; (Aint(rA,rB,mid) >= Math.PI*(rA*rA/totA)*common) ? lo=mid : hi=mid; } d=(lo+hi)/2; }

  const span = d + rA + rB; if (span > boxW){ const sf = boxW/span; rA*=sf; rB*=sf; d*=sf; }

  const cy = m.top + boxH*0.50;
  const startX = m.left + (boxW - (d + rA + rB))/2;
  const xA = startX + rA, xB = xA + d;

  const add = (n, attrs) => { const el=document.createElementNS("http://www.w3.org/2000/svg",n); for (const k in attrs) el.setAttribute(k, attrs[k]); svg.appendChild(el); return el; };

  const fillA="#007FFF", fillB="#bf430b", fillAB="#ff1fab";
  add("circle",{cx:xA, cy, r:rA, fill:fillA});
  add("circle",{cx:xB, cy, r:rB, fill:fillB});

  (function drawOverlapLens(){
    if (d >= rA + rB) return;
    if (d <= Math.abs(rA - rB)) { const cx=(rA<=rB)?xA:xB; add("circle",{cx, cy, r:Math.min(rA,rB), fill:fillAB}); return; }
    const a1=Math.acos(clamp1((d*d+rA*rA-rB*rB)/(2*d*rA)));
    const a2=Math.acos(clamp1((d*d+rB*rB-rA*rA)/(2*d*rB)));
    const p1x=xA+rA*Math.cos(a1), p1y=cy-rA*Math.sin(a1);
    const p2x=xA+rA*Math.cos(-a1),p2y=cy-rA*Math.sin(-a1);
    const q1x=xB+rB*Math.cos(Math.PI-a2), q1y=cy-rB*Math.sin(Math.PI-a2);
    const path=[`M ${p1x} ${p1y}`,`A ${rA} ${rA} 0 0 1 ${p2x} ${p2y}`,`A ${rB} ${rB} 0 0 1 ${q1x} ${q1y}`,`A ${rA} ${rA} 0 0 0 ${p1x} ${p1y}`,"Z"].join(" ");
    add("path",{d:path, fill:fillAB});
  })();

  const total = totA + totB - common;
  const uniqueA = totA - common, uniqueB = totB - common;
  const pct = v => total ? Math.round(100*v/total) : 0;

  const tip = $("#vennTip"), wrap=$("#vennWrap");
  function placeTip(e){
    const R=wrap.getBoundingClientRect();
    const x=e.clientX-R.left+12, y=e.clientY-R.top+12;
    const maxX=R.width-tip.offsetWidth-8, maxY=R.height-tip.offsetHeight-8;
    tip.style.left=Math.max(8,Math.min(x,maxX))+"px";
    tip.style.top =Math.max(8,Math.min(y,maxY))+"px";
  }
  function attachTip(el, textFn){
    el.addEventListener("mouseenter", ()=>{ tip.style.display="block"; tip.textContent=textFn(); });
    el.addEventListener("mousemove", placeTip);
    el.addEventListener("mouseleave", ()=>{ tip.style.display="none"; });
  }

  const fontNumPx=Math.max(12,Math.min(18,Math.round(Math.min(rA,rB)*0.22)));
  const fontNamePx=Math.max(12,Math.min(16,Math.round(Math.min(rA,rB)*0.18)));
  const fontNum =`${fontNumPx}px "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`;
  const fontName=`${fontNamePx}px "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`;

  const txt=(attrs,s)=>{ const t=add("text",attrs); t.textContent=s; return t; };
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));

  const hasOverlap = d < rA + rB && d > Math.abs(rA - rB);
  const contained  = d <= Math.abs(rA - rB);
  const safeD=Math.max(d,1e-6);
  let aA=rA, aB=rB;
  if(hasOverlap){ aA=(safeD*safeD+rA*rA-rB*rB)/(2*safeD); aB=(safeD*safeD+rB*rB-rA*rA)/(2*safeD); }
  else if(contained){ aA=(rA<=rB)?0:rA; aB=(rB<=rA)?0:rB; }

  const uA=totA-common, uB=totB-common;
  const xTotA=(uA>0&&hasOverlap)? xA+(aA-rA)/2 : xA;
  const xTotB=(uB>0&&hasOverlap)? xB+(rB-aB)/2 : xB;
  const yTotA=uA>0?cy:cy-rA*0.30;
  const yTotB=uB>0?cy:cy-rB*0.30;

  const xLens = contained ? (rA<=rB?xA:xB) : (hasOverlap ? (xA+aA + xB-aB)/2 : (xA+xB)/2);
  const leftContained  = (d <= Math.abs(rA - rB)) && (rA <= rB);
  const rightContained = (d <= Math.abs(rA - rB)) && (rB <= rA);

  if(!leftContained)  txt({x:xTotA,y:yTotA,"text-anchor":"middle",fill:"#000",style:`font:${fontNum};pointer-events:none`}, `${totA}`);
  if(common>0)        txt({x:xLens,y:cy,   "text-anchor":"middle",fill:"#000",style:`font:${fontNum};pointer-events:none`}, `${common}`);
  if(!rightContained) txt({x:xTotB,y:yTotB,"text-anchor":"middle",fill:"#000",style:`font:${fontNum};pointer-events:none`}, `${totB}`);

  function placeName(cx,cy0,r,deg,label,anchor){
    const theta=(Math.PI/180)*deg, offset=Math.max(16,r*0.28);
    let x=cx+(r+offset)*Math.cos(theta), y=cy0+(r+offset)*Math.sin(theta);
    const xMin=m.left+6, xMax=W-m.right-6, yMin=m.top+6, yMax=H-m.bottom-6;
    x=clamp(x,xMin,xMax); y=clamp(y,yMin,yMax);
    return txt({x,y,"text-anchor":anchor,fill:"#000",style:`font:${fontName};cursor:help`},label);
  }
  const nameAEl=placeName(xA,cy,rA,-150,aName,"start");
  const nameBEl=placeName(xB,cy,rB, -30,bName,"start");
  attachTip(nameAEl, ()=> `${uniqueA} unique (${pct(uniqueA)}%)`);
  attachTip(nameBEl, ()=> `${uniqueB} unique (${pct(uniqueB)}%)`);

  const leftHit  = add("circle",{cx:xA, cy, r:rA, fill:"rgba(0,0,0,0.001)"});  attachTip(leftHit,  ()=> `${uniqueA} unique (${pct(uniqueA)}%)`);
  const rightHit = add("circle",{cx:xB, cy, r:rB, fill:"rgba(0,0,0,0.001)"});  attachTip(rightHit, ()=> `${uniqueB} unique (${pct(uniqueB)}%)`);

  (function(){
    if (d >= rA + rB) return;
    if (d <= Math.abs(rA - rB)) {
      const cx = (rA <= rB) ? xA : xB;
      const rr = Math.min(rA, rB);
      const lensHit = add("circle",{cx, cy, r: rr, fill:"rgba(0,0,0,0.001)"});
      attachTip(lensHit, ()=> `${common} in common (${pct(common)}% of union)`);
      return;
    }
    const a1=Math.acos(clamp1((d*d+rA*rA-rB*rB)/(2*d*rA)));
    const a2=Math.acos(clamp1((d*d+rB*rB-rA*rA)/(2*d*rB)));
    const p1x=xA+rA*Math.cos(a1), p1y=cy-rA*Math.sin(a1);
    const p2x=xA+rA*Math.cos(-a1),p2y=cy-rA*Math.sin(-a1);
    const q1x=xB+rB*Math.cos(Math.PI-a2), q1y=cy-rB*Math.sin(Math.PI-a2);
    const dLens=[`M ${p1x} ${p1y}`,`A ${rA} ${rA} 0 0 1 ${p2x} ${p2y}`,`A ${rB} ${rB} 0 0 1 ${q1x} ${q1y}`,`A ${rA} ${rA} 0 0 0 ${p1x} ${p1y}`,"Z"].join(" ");
    const lensHit = add("path",{d:dLens, fill:"rgba(0,0,0,0.001)"});
    attachTip(lensHit, ()=> `${common} in common (${pct(common)}% of union)`);
  })();
}
// --- end Venn Diagram ---



// --- Heatmap ------------------------------------------------------------------
function drawHeatmap(rows, aName="A", bName="B"){
  const svg=$("#heatSVG"), tip=$("#heatTip"), status=$("#statusM"), sum=$("#summaryM");
  const W=600, H=600, m={left:68, right:28, top:36, bottom:72};
  svg.innerHTML="";
  if(!rows || !rows.length){ setStatus(status,"No overlap yet."); sum.textContent=""; return; }
  setStatus(status,"");

  const {xScale,yScale,x0,x1,y0,y1} =
  gridAndTicks(svg, W, H, m, 0.5, 5.0, 0.5, 5.0, 0.5, 0.5, `${aName} rating`, `${bName} rating`, true, true);

  const step=0.5, base=0.5, vals=Array.from({length:10},(_,i)=>+(base + i*step).toFixed(1));

  const counts = new Map(); let maxCount=0;
  rows.forEach(r=>{
    const ax = +(Math.round(r.a/step)*step).toFixed(1);
    const by = +(Math.round(r.b/step)*step).toFixed(1);
    const k = `${ax}|${by}`;
    const v = (counts.get(k)||0) + 1;
    counts.set(k, v);
    if(v>maxCount) maxCount=v;
  });

  const bins = vals.length;
  const bandX  = (x1 - x0) / bins;
  const bandY  = (y0 - y1) / bins;
  const cellW  = bandX * 0.92;
  const cellH  = bandY * 0.92;
  const padX   = (bandX - cellW) / 2;
  const padY   = (bandY - cellH) / 2;

  function color(t){
    const stops = [{p:0.0,c:[0,127,255]},{p:0.5,c:[255,31,171]},{p:1.0,c:[191,67,11]}];
    const v=Math.max(0,Math.min(1,t)); let i=0; while(i<stops.length-1 && v>stops[i+1].p) i++;
    const a=stops[i], b=stops[i+1], u=(v-a.p)/(b.p-a.p||1);
    const R=Math.round(a.c[0]+(b.c[0]-a.c[0])*u);
    const G=Math.round(a.c[1]+(b.c[1]-a.c[1])*u);
    const B=Math.round(a.c[2]+(b.c[2]-a.c[2])*u);
    return `rgb(${R},${G},${B})`;
}

  const wrap=$("#heatWrap");
  function placeTip(e){
    const R=wrap.getBoundingClientRect();
    const x=e.clientX-R.left+12, y=e.clientY-R.top+12;
    const maxX=R.width-tip.offsetWidth-8, maxY=R.height-tip.offsetHeight-8;
    tip.style.left=Math.max(8,Math.min(x,maxX))+"px";
    tip.style.top =Math.max(8,Math.min(y,maxY))+"px";
  }

  vals.forEach((ax, i)=>{
    vals.forEach((by, j)=>{
      const k = `${ax}|${by}`;
      const v = counts.get(k) || 0;

      const x = x0 + i * bandX + padX;
      const y = y1 + (bins - 1 - j) * bandY + padY;
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", x); rect.setAttribute("y", y);
      rect.setAttribute("width",  cellW); rect.setAttribute("height", cellH);
      rect.setAttribute("fill", v ? color(v/maxCount) : "rgb(240,240,255)");
      rect.setAttribute("stroke", "#e6e6f8");
      rect.addEventListener("mouseenter",()=>{
        if(!v) return;
        tip.style.display="block";
        tip.textContent = `${aName} ${ax}★, ${bName} ${by}★ — ${v} (${Math.round(100*v/rows.length)}%)`;
      });
      rect.addEventListener("mousemove", placeTip);
      rect.addEventListener("mouseleave",()=>{ tip.style.display="none"; });
      svg.appendChild(rect);

      if(v>0 && cellW>=40 && cellH>=24){
        const t = document.createElementNS("http://www.w3.org/2000/svg","text");
        t.setAttribute("x", x + cellW/2); t.setAttribute("y", y + cellH/2 + 4);
        t.setAttribute("text-anchor","middle"); t.setAttribute("class","tick"); t.textContent = v;
        svg.appendChild(t);
      }
    });
  });
  const diag=document.createElementNS("http://www.w3.org/2000/svg","line");
  diag.setAttribute("x1", x0); diag.setAttribute("y1", y0);
  diag.setAttribute("x2", x1); diag.setAttribute("y2", y1);
  diag.setAttribute("class","diag"); svg.appendChild(diag);
}

// --- Histogram of absolute differences ---------------------------------------
function drawHistogram(rows, aName="A", bName="B"){
  const svg=$("#histSVG"), tip=$("#histTip"), status=$("#statusH"), sum=$("#summaryH");
  const W=700, H=520, m={left:68, right:28, top:36, bottom:72};
  svg.innerHTML="";
  if(!rows || !rows.length){ setStatus(status,"No overlap yet."); sum.textContent=""; return; }
  setStatus(status,"");

  const step=0.5;
  const bins=Array.from({length:10},(_,i)=>+(i*step).toFixed(1));
  const counts=new Array(bins.length).fill(0);
  rows.forEach(r=>{ const d=Math.abs(r.a-r.b); const idx=Math.round(d/step); if(idx>=0 && idx<counts.length) counts[idx]++; });
  const n=rows.length, props=counts.map(c=>100*c/n);
  const yMaxDyn=Math.min(100, Math.max(10, Math.ceil(Math.max(...props,0)/10)*10));
  sum.textContent = `Exact ${props[0].toFixed(0)}% · ≤0.5★ ${(props[0]+props[1]).toFixed(0)}% · ≤1★ ${(props[0]+props[1]+props[2]).toFixed(0)}%`;

  const {xScale,yScale,x0,x1,y0,y1} =
    gridAndTicks(svg, W, H, m, 0, 4.5, 0, yMaxDyn, 0.5, 10, `|${aName}−${bName}| (★)`, "Share of titles (%)", true, false);

  const band=(x1-x0)/bins.length, barW=band*0.72;

  const wrap=$("#histWrap");
  function placeTip(e){
    const R=wrap.getBoundingClientRect();
    const x=e.clientX-R.left+12, y=e.clientY-R.top+12;
    const maxX=R.width-tip.offsetWidth-8, maxY=R.height-tip.offsetHeight-8;
    tip.style.left=Math.max(8,Math.min(x,maxX))+"px";
    tip.style.top =Math.max(8,Math.min(y,maxY))+"px";
  }

  bins.forEach((b,i)=>{
    const v=props[i];
    const x=x0 + i*band + (band-barW)/2;
    const y=yScale(v), h=yScale(0)-y;

    const r=document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("x",x); r.setAttribute("y",y);
    r.setAttribute("width",barW); r.setAttribute("height",Math.max(0,h));
    r.setAttribute("fill","#666666"); r.setAttribute("stroke","#e0e0e0");
    r.addEventListener("mouseenter", ()=>{ tip.style.display="block"; tip.textContent=`|${aName}−${bName}| = ${b}★ → ${v.toFixed(1)}% (${counts[i]} films)`; });
    r.addEventListener("mousemove", placeTip);
    r.addEventListener("mouseleave", ()=>{ tip.style.display="none"; });
    svg.appendChild(r);

    if(v>=0.5){
      const t=document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", x+barW/2); t.setAttribute("y", y-6);
      t.setAttribute("text-anchor","middle"); t.setAttribute("class","tick");
      t.textContent = v.toFixed(0) + "%"; svg.appendChild(t);
    }
  });
}

  function drawTotalHours(){
  const svg = $("#watchSVG"), tip=$("#watchTip"), status=$("#statusT"), sum=$("#summaryT");
  svg.innerHTML="";
  if (!watchA && !watchB){ setStatus(status, "No diary logs found."); sum.textContent=""; return; }
  setStatus(status,"");

  const uA = normUser($("#userA").value) || "A";
  const uB = normUser($("#userB").value) || "B";

  const data = [
    {user:uA, minutes:watchA},
    {user:uB, minutes:watchB}
  ];
  const hours = data.map(d=>d.minutes/60);
  const maxH = Math.max(1, Math.ceil(Math.max(...hours)));

  const W=700, H=320, m={left:80,right:24,top:30,bottom:48};
  const x0=m.left, y0=m.top, innerW=W-m.left-m.right, innerH=H-m.top-m.bottom;

  // scales
  const x = (i)=> x0 + (i+0.1)*innerW/2;
  const bw = innerW/2*0.8;
  const y = (v)=> y0 + innerH - (v/maxH)*innerH;

  // axes
  const gY = document.createElementNS("http://www.w3.org/2000/svg","g");
  for(let t=0; t<=maxH; t+=Math.max(1, Math.ceil(maxH/5))){
    const yy = y(t);
    const gl = document.createElementNS("http://www.w3.org/2000/svg","line");
    gl.setAttribute("x1", x0); gl.setAttribute("x2", x0+innerW);
    gl.setAttribute("y1", yy); gl.setAttribute("y2", yy);
    gl.setAttribute("class", "gridline");
    svg.appendChild(gl);

    const lbl = document.createElementNS("http://www.w3.org/2000/svg","text");
    lbl.setAttribute("x", x0-10); lbl.setAttribute("y", yy+4);
    lbl.setAttribute("text-anchor","end"); lbl.setAttribute("class","tick");
    lbl.textContent = t + " h";
    svg.appendChild(lbl);
  }

  // bars
  data.forEach((d,i)=>{
    const h = hours[i];
    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", x(i)); rect.setAttribute("y", y(h));
    rect.setAttribute("width", bw); rect.setAttribute("height", (h/maxH)*innerH);
    rect.setAttribute("fill", "#2a3745");
    rect.addEventListener("mousemove", (ev)=>{
  const wrap = $("#watchWrap");
  const R = wrap.getBoundingClientRect();
  tip.style.display = "block";
  tip.textContent = `${d.user}: ${h.toFixed(2)} hours (${d.minutes} min)`;
  const x = ev.clientX - R.left + 12;
  const y = ev.clientY - R.top  + 12;
  const maxX = R.width  - tip.offsetWidth  - 8;
  const maxY = R.height - tip.offsetHeight - 8;
  tip.style.left = Math.max(8, Math.min(x, maxX)) + "px";
  tip.style.top  = Math.max(8, Math.min(y, maxY)) + "px";
});
    rect.addEventListener("mouseleave", ()=>{ tip.style.display="none"; });
    svg.appendChild(rect);

    const name = document.createElementNS("http://www.w3.org/2000/svg","text");
    name.setAttribute("x", x(i)+bw/2); name.setAttribute("y", y0+innerH+20);
    name.setAttribute("text-anchor","middle"); name.setAttribute("class","tick");
    name.textContent = d.user;
    svg.appendChild(name);

    const val = document.createElementNS("http://www.w3.org/2000/svg","text");
    val.setAttribute("x", x(i)+bw/2); val.setAttribute("y", y(h)-8);
    val.setAttribute("text-anchor","middle"); val.setAttribute("class","tick");
    val.textContent = h.toFixed(2)+" h";
    svg.appendChild(val);
  });

  const total = hours.reduce((s,v)=>s+v,0);
  sum.textContent = `Total: ${total.toFixed(2)} hours across both users`;
}

// --- Star animation (ratings curve over time) -------------------------------
const STAR_BINS = [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0];
let starAnimTimer = null;
let starDomReady = false;

function prepareStarSequence(list){
  if (!Array.isArray(list) || !list.length) return [];
  const ratings = list
    .map(it => (typeof it.rating === "number" ? it.rating : null))
    .filter(v => v !== null && isFinite(v))
    .map(v => Math.max(0.5, Math.min(5.0, v)));
  // ratings API is newest → oldest; reverse so we animate oldest → newest
  ratings.reverse();
  return ratings;
}

function ratingToBinIndex(r){
  const step = 0.5;
  const idx = Math.round((r - 0.5) / step);
  return (idx >= 0 && idx < STAR_BINS.length) ? idx : -1;
}

function ensureStarDom(){
  if (starDomReady) return;
  const wrapA = document.getElementById("starBarsA");
  const wrapB = document.getElementById("starBarsB");
  if (!wrapA || !wrapB) return;
  wrapA.innerHTML = "";
  wrapB.innerHTML = "";
  STAR_BINS.forEach(() => {
    const a = document.createElement("div");
    a.className = "star-bar";
    a.style.height = "4%";
    wrapA.appendChild(a);
    const b = document.createElement("div");
    b.className = "star-bar";
    b.style.height = "4%";
    wrapB.appendChild(b);
  });
  starDomReady = true;
}

function updateStarBars(countsA, countsB){
  const barsA = document.querySelectorAll("#starBarsA .star-bar");
  const barsB = document.querySelectorAll("#starBarsB .star-bar");
  if (!barsA.length || !barsB.length) return;
  const maxCount = Math.max(1, ...countsA, ...countsB);
  barsA.forEach((el, i) => {
    const c = countsA[i] || 0;
    const h = maxCount ? (c / maxCount) * 100 : 0;
    el.style.height = (h || 4) + "%";
  });
  barsB.forEach((el, i) => {
    const c = countsB[i] || 0;
    const h = maxCount ? (c / maxCount) * 100 : 0;
    el.style.height = (h || 4) + "%";
  });
}

function startStarAnimation(){
  const status    = document.getElementById("statusS");
  const summary   = document.getElementById("summaryS");
  const nameAEl   = document.getElementById("starUserA");
  const nameBEl   = document.getElementById("starUserB");
  const progAEl   = document.getElementById("starProgressA");
  const progBEl   = document.getElementById("starProgressB");

  if (!status || !summary) return;

  const seqA = prepareStarSequence(lastA);
  const seqB = prepareStarSequence(lastB);

  const totalA = seqA.length;
  const totalB = seqB.length;
  const totalFrames = Math.max(totalA, totalB);   // both finish together

  const aName = (document.getElementById("userA").value || "A").trim() || "A";
  const bName = (document.getElementById("userB").value || "B").trim() || "B";
  if (nameAEl) nameAEl.textContent = aName;
  if (nameBEl) nameBEl.textContent = bName;

  if (starAnimTimer){
    clearInterval(starAnimTimer);
    starAnimTimer = null;
  }
  ensureStarDom();

  const emptyCounts = new Array(STAR_BINS.length).fill(0);

  if (!totalFrames){
    status.textContent  = "Need ratings from at least one user.";
    summary.textContent = "Oldest → Newest";
    updateStarBars(emptyCounts, emptyCounts);
    if (progAEl) progAEl.textContent = "";
    if (progBEl) progBEl.textContent = "";
    return;
  }

  status.textContent  = "";
  summary.textContent = "Oldest → Newest";

  const fmt = n => n.toLocaleString("en-US");

  if (progAEl) progAEl.textContent = `${fmt(0)}/${fmt(totalA)}`;
  if (progBEl) progBEl.textContent = `${fmt(0)}/${fmt(totalB)}`;

  const countsA = new Array(STAR_BINS.length).fill(0);
  const countsB = new Array(STAR_BINS.length).fill(0);

  // per-user progress
  let frame = 0;
  let idxA = 0, idxB = 0;
  let accA = 0, accB = 0;

  // smaller n → smaller step → slower rate
  const stepA = totalA ? totalA / totalFrames : 0;
  const stepB = totalB ? totalB / totalFrames : 0;

  const stepDelay = 160;          // ms between frames

  // initial empty frame
  updateStarBars(emptyCounts, emptyCounts);

  function tick(){
    if (frame < totalFrames){
      // accumulate fractional progress
      accA += stepA;
      accB += stepB;

      // add at most 1 rating per user per frame
      if (idxA < totalA && accA >= 1){
        accA -= 1;
        const binA = ratingToBinIndex(seqA[idxA]);
        if (binA >= 0) countsA[binA]++;
        idxA++;
      }
      if (idxB < totalB && accB >= 1){
        accB -= 1;
        const binB = ratingToBinIndex(seqB[idxB]);
        if (binB >= 0) countsB[binB]++;
        idxB++;
      }

      updateStarBars(countsA, countsB);
      if (progAEl) progAEl.textContent = `${fmt(idxA)}/${fmt(totalA)}`;
      if (progBEl) progBEl.textContent = `${fmt(idxB)}/${fmt(totalB)}`;

      frame++;
    }

    if (frame >= totalFrames){
      // safety: make sure any leftover ratings (from rounding) are added
      while (idxA < totalA){
        const binA = ratingToBinIndex(seqA[idxA]);
        if (binA >= 0) countsA[binA]++;
        idxA++;
      }
      while (idxB < totalB){
        const binB = ratingToBinIndex(seqB[idxB]);
        if (binB >= 0) countsB[binB]++;
        idxB++;
      }
      updateStarBars(countsA, countsB);
      if (progAEl) progAEl.textContent = `${fmt(totalA)}/${fmt(totalA)}`;
      if (progBEl) progBEl.textContent = `${fmt(totalB)}/${fmt(totalB)}`;

      clearInterval(starAnimTimer);
      starAnimTimer = null;
    }
  }

  starAnimTimer = setInterval(tick, stepDelay);

  const replayBtn = document.getElementById("starReplay");
  if (replayBtn && !replayBtn._bound){
    replayBtn._bound = true;
    replayBtn._bound = true;
    replayBtn.addEventListener("click", () => {
      startStarAnimation();
    });
  }
}
  
// --- Orchestration ------------------------------------------------------------
function updateAllViews(){
  const rows = computeOverlap();

  const status=$("#statusO"), tbl=$("#tblO"), tbody=$("#tblO tbody"), summary=$("#summaryO"), statsEl=$("#stats");
  if(!rows.length){
    setStatus(status,"Fetch both to see overlaps.");
    tbl.hidden=true; summary.textContent=""; statsEl.textContent="";
  } else {
    setStatus(status,""); summary.textContent=`${rows.length} films in common`;
    tbody.innerHTML = rows.map(r=>`<tr><td>${r.title}</td><td class="num">${r.a.toFixed(1)}</td><td class="num">${r.b.toFixed(1)}</td></tr>`).join("");
    tbl.hidden=false;
    const s = calcStats(rows);
    const rho = spearmanRho(rows);
    const kq  = kappaQuadratic(rows);
      statsEl.textContent =
      `Exact ${s.pct0.toFixed(0)}% · ≤0.5★ ${s.pct05.toFixed(0)}% · ≤1★ ${s.pct10.toFixed(0)}% ` +
      `· Bias (A−B): ${s.meanBias.toFixed(2)}★ · MAE: ${s.mae.toFixed(2)}★ · Spearman's ρ: ${rho.toFixed(2)} · Cohen's κ: ${kq.toFixed(2)}`;
  }

  const aName = ($("#userA").value || "A").trim() || "A";
  const bName = ($("#userB").value || "B").trim() || "B";
  drawVenn(computeTotalsUnique(), aName, bName);
  drawHeatmap(rows, aName, bName);
    drawHistogram(rows, aName, bName);
  renderDescriptiveStats();
  renderByYear();

  // NEW
  drawTotalHours();
}

async function runBoth(){
  const status = $("#statusO");
  let uA = normUser($("#userA").value);
  let uB = normUser($("#userB").value);

  // If both empty, auto-fill defaults
  if(!uA && !uB){
    uA = "eddieslb";
    uB = "steedmanson";
    $("#userA").value = uA;
    $("#userB").value = uB;
  }

  if(!uA || !uB){ setStatus(status,"Enter two valid usernames.", true); return; }

  showLoadingBar();
  try{
    const [a, b, da, db, wa, wb] = await Promise.all([
      fetchRatings(uA), fetchRatings(uB),
      fetchDiary(uA, 200), fetchDiary(uB, 200),
      fetchWatchtime(uA, 200), fetchWatchtime(uB, 200)
    ]);

    lastA = a.items || [];
    lastB = b.items || [];
    diaryA = da || null;
    diaryB = db || null;
    watchA = (wa && wa.minutes) ? wa.minutes : 0;
    watchB = (wb && wb.minutes) ? wb.minutes : 0;

    setStatus(status,"");
    updateAllViews();
  } catch(e){
    setStatus(status, e.message || String(e), true);
    lastA = []; lastB = [];
    diaryA = null; diaryB = null;
    watchA = 0; watchB = 0;
    updateAllViews();
  } finally {
    hideLoadingBar();
  }
}


$("#userA").addEventListener("keydown", e => { if(e.key==="Enter"){ e.preventDefault(); runBoth(); }});
$("#userB").addEventListener("keydown", e => { if(e.key==="Enter"){ e.preventDefault(); runBoth(); }});
 
function renderByYear(){
  const s = $("#statusY"), sum = $("#summaryY");
  const hasA = !!(diaryA && diaryA.years && Object.keys(diaryA.years).length);
  const hasB = !!(diaryB && diaryB.years && Object.keys(diaryB.years).length);

  if (!hasA && !hasB){
    setStatus(s,"No diary logs found."); 
    sum.textContent="";
    $("#yearA").innerHTML=""; 
    $("#yearB").innerHTML="";
    return;
  }

  setStatus(s,"");
  sum.textContent = "Films logged per year";
  if (hasA) {
    drawYearBars($("#yearA"), diaryA.years, ($("#userA").value||"A").trim()||"A");
  } else {
    $("#yearA").innerHTML="";
  }
  if (hasB) {
    drawYearBars($("#yearB"), diaryB.years, ($("#userB").value||"B").trim()||"B");
  } else {
    $("#yearB").innerHTML="";
  }
}


function drawYearBars(svgEl, yearCounts, label){
  const svgNS="http://www.w3.org/2000/svg";
  const W=1200, H=220, padL=56, padR=24, padT=24, padB=36;
  const innerW=W-padL-padR, innerH=H-padT-padB;

  const allYears = Object.keys(yearCounts||{}).map(x=>+x).sort((a,b)=>a-b);
  let startIdx = 0, endIdx = allYears.length - 1;
  while (startIdx <= endIdx && ((yearCounts[allYears[startIdx]]||0) === 0)) startIdx++;
  while (endIdx >= startIdx && ((yearCounts[allYears[endIdx]]||0) === 0)) endIdx--;
  const years = startIdx <= endIdx ? allYears.slice(startIdx, endIdx + 1) : [];
  if (years.length===0){ svgEl.innerHTML=""; return; }
  const maxCnt = Math.max(1, ...years.map(y=>yearCounts[y]||0));
  const yScale = c => padT + innerH - (c/maxCnt)*innerH;

  svgEl.setAttribute("viewBox", `0 0 ${W} ${H}`);
  svgEl.innerHTML = "";

  const gAxis = document.createElementNS(svgNS,"g");
  const base = document.createElementNS(svgNS,"line");
  base.setAttribute("x1", padL); base.setAttribute("y1", padT+innerH);
  base.setAttribute("x2", padL+innerW); base.setAttribute("y2", padT+innerH);
  base.setAttribute("stroke","var(--grid)"); base.setAttribute("stroke-width","1");
  gAxis.appendChild(base);
  const t1 = document.createElementNS(svgNS,"text");
  t1.setAttribute("x", padL); t1.setAttribute("y", H-8);
  t1.setAttribute("fill","var(--muted)"); t1.setAttribute("style","font:12px Inter, system-ui");
  t1.textContent = years[0]; gAxis.appendChild(t1);
  const t2 = document.createElementNS(svgNS,"text");
  t2.setAttribute("x", padL+innerW); t2.setAttribute("y", H-8);
  t2.setAttribute("text-anchor","end");
  t2.setAttribute("fill","var(--muted)"); t2.setAttribute("style","font:12px Inter, system-ui");
  t2.textContent = years[years.length-1]; gAxis.appendChild(t2);
  svgEl.appendChild(gAxis);

  const defs = document.createElementNS(svgNS,"defs");
  const grad = document.createElementNS(svgNS,"linearGradient");
  grad.setAttribute("id","yearGrad");
  grad.setAttribute("gradientUnits","userSpaceOnUse");
  grad.setAttribute("x1", String(padL));
  grad.setAttribute("y1", "0");
  grad.setAttribute("x2", String(padL+innerW));
  grad.setAttribute("y2", "0");
  [["0%","#007FFF"],["50%","#ff1fab"],["100%","#bf430b"]].forEach(([o,c])=>{
    const s=document.createElementNS(svgNS,"stop"); s.setAttribute("offset",o); s.setAttribute("stop-color",c); grad.appendChild(s);
  });
  defs.appendChild(grad); svgEl.appendChild(defs);

  const n=years.length, step=innerW/n;
  const bw = Math.max(6, step*0.98);
  const centers = years.map((_,i)=> padL + (i+0.5)*step);

  for (let i=0;i<n;i++){
    const y=years[i], c=yearCounts[y]||0, cx=centers[i];
    const r=document.createElementNS(svgNS,"rect");
    r.setAttribute("x", cx-bw/2); r.setAttribute("y", yScale(c));
    r.setAttribute("width", bw); r.setAttribute("height", Math.max(0, padT+innerH - yScale(c)));
    r.setAttribute("rx","3"); r.setAttribute("fill","url(#yearGrad)"); r.setAttribute("opacity","0.95");
    svgEl.appendChild(r);
  }

  const chip = document.createElementNS(svgNS,"text");
  chip.setAttribute("x", 56); chip.setAttribute("y", 16);
  chip.setAttribute("fill","var(--muted)"); chip.setAttribute("style","font:12px Inter, system-ui");
  chip.textContent = label; svgEl.appendChild(chip);

  const tipEl = document.getElementById("yearTip");
  const wrap = document.getElementById("panelY");
  function placeTip(ev){
    const R = wrap.getBoundingClientRect();
    const x = ev.clientX - R.left + 12;
    const y = ev.clientY - R.top  + 12;
    const maxX = R.width  - tipEl.offsetWidth  - 8;
    const maxY = R.height - tipEl.offsetHeight - 8;
    tipEl.style.left = Math.max(8, Math.min(x, maxX)) + "px";
    tipEl.style.top  = Math.max(8, Math.min(y, maxY)) + "px";
  }
  function showYearTip(year, cnt, ev){
    tipEl.style.display="block";
    tipEl.textContent = `${year}: ${cnt}`;
    placeTip(ev);
  }
  function hideYearTip(){ tipEl.style.display="none"; }

  for (let i=0;i<n;i++){
    const y=years[i], c=yearCounts[y]||0, cx=centers[i];
    const hit=document.createElementNS(svgNS,"rect");
    hit.setAttribute("class","hit");
    hit.setAttribute("x", cx-step/2); hit.setAttribute("y", padT);
    hit.setAttribute("width", step);  hit.setAttribute("height", innerH);
    hit.setAttribute("fill","rgba(0,0,0,0.001)");
    hit.addEventListener("pointerenter", ev=>showYearTip(y,c,ev));
    hit.addEventListener("pointermove",  ev=>placeTip(ev));
    hit.addEventListener("pointerdown",  ev=>showYearTip(y,c,ev));
    hit.addEventListener("pointerleave", e => { if (e.pointerType === "mouse") hideYearTip(); });
    svgEl.appendChild(hit);
  }

  document.addEventListener("pointerdown", e=>{
    if(!e.target.closest("#panelY .hit")) hideYearTip();
  }, {capture:true});
}

// --- Mutual Movies sorting ---
const MUTUAL_SORT = { key: "title", dir: 1 }; // dir: 1 = ascending, -1 = descending

function applyMutualSort(){
  const tbody = document.querySelector("#tblO tbody");
  if(!tbody) return;
  const rows = Array.from(tbody.querySelectorAll("tr"));

  const getVal = (tr, key) => {
    if(key==="title") return tr.children[0].textContent.trim().toLowerCase();
    if(key==="a")     return parseFloat(tr.children[1].textContent) || 0;
    if(key==="b")     return parseFloat(tr.children[2].textContent) || 0;
    return 0;
  };

  rows.sort((r1, r2) => {
    const v1 = getVal(r1, MUTUAL_SORT.key);
    const v2 = getVal(r2, MUTUAL_SORT.key);
    if(MUTUAL_SORT.key === "title"){
      return v1.localeCompare(v2, "en", {sensitivity:"base"}) * MUTUAL_SORT.dir;
    }
    return (v1 - v2) * MUTUAL_SORT.dir;
  });

  rows.forEach(r => tbody.appendChild(r));
  updateSortIndicators();
}

function updateSortIndicators(){
  document.querySelectorAll("#tblO thead .sort-btn").forEach(btn => {
    const active = btn.dataset.key === MUTUAL_SORT.key;
    btn.classList.toggle("sorted", active);
    const arrow = btn.querySelector(".arrow");
    arrow.textContent = active ? (MUTUAL_SORT.dir === 1 ? "▲" : "▼") : "";
    btn.setAttribute("aria-sort", active ? (MUTUAL_SORT.dir === 1 ? "ascending" : "descending") : "none");
  });
}

function attachMutualSortHandlers(){
  document.querySelectorAll("#tblO thead .sort-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const k = btn.dataset.key;
      if(MUTUAL_SORT.key === k){
        MUTUAL_SORT.dir *= -1;       // toggle
      } else {
        MUTUAL_SORT.key = k;
        MUTUAL_SORT.dir = 1;         // start ascending on new key
      }
      applyMutualSort();
    });
  });
}

// Patch updateAllViews so the table always respects the current sort and extras.
(function(){
  const _update = updateAllViews;
  updateAllViews = function(){
    _update();
    attachMutualSortHandlers();
    applyMutualSort();
    setMutualHeaderAvatars();
    startStarAnimation();  // NEW: animate ratings curve
  };
})();

// Fetch and set header avatars based on current input usernames.
const _avatarCache = new Map();
async function fetchAvatar(user){
  if(!user) return null;
  if(_avatarCache.has(user)) return _avatarCache.get(user);
  try{
    const r = await fetch(`/api/avatar?user=${encodeURIComponent(user)}`);
    const j = await r.json();
    const url = (j && j.avatar) || null;
    _avatarCache.set(user, url);
    return url;
  }catch{ return null; }
}

async function setMutualHeaderAvatars(){
  const aImg = document.getElementById("hdrA");
  const bImg = document.getElementById("hdrB");
  if(!aImg || !bImg) return;

  const nameA = (document.getElementById("userA").value||"A").trim()||"A";
  const nameB = (document.getElementById("userB").value||"B").trim()||"B";
  aImg.title = nameA; bImg.title = nameB;

  const [srcA, srcB] = await Promise.all([fetchAvatar(nameA), fetchAvatar(nameB)]);
  if(srcA) aImg.src = srcA;
  if(srcB) bImg.src = srcB;

  document.querySelector('#tblO [data-key="a"]')?.setAttribute('aria-label', `Sort by ${nameA}'s rating`);
  document.querySelector('#tblO [data-key="b"]')?.setAttribute('aria-label', `Sort by ${nameB}'s rating`);
}
  
</script>
</body>
</html>
